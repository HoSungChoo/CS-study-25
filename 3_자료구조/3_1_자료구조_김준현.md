# 1. 자료구조의 큰 그림

## 자료구조와 알고리즘

### 자료구조 

- 데이터를 저장하고 관리하는 방식
  
- 어떤 자료구조를 사용하느냐에 따라서 사용할 수 있는 알고리즘이 정해지는 경우가 많다.
  
  - ex) BFS - 큐 / 재귀 - 스택 / 다익스트라 - 우선순위큐 등
    
  - 자료구조의 선택에 따라 알고리즘의 성능과 효율성이 크게 달라질 수 있다. 
  
- 자료구조는 데이터를 효율적으로 저장하고 관리하는 방식을 의미한다. 

- 프로그램에서 데이터를 정리하고 저장하는 방법은 문제를 해결하는 데 있어서 중요한 역할을 한다.

- 적절한 자료구조를 사용하면 알고리즘의 성능과 효율성을 극대화할 수 있다.

- 자료구조는 크게 선형 자료구조와 비선형 자료구조로 구분된다.

  - 선형 자료구조
  
    - 데이터가 일렬로 배치되어 순서대로 접근 가능한 구조

    - ex) 배열(Array), 연결리스트(Linked List), 스택(Stack), 큐(Queue), 우선순위큐(Priority queue)

  - 비선형 자료구조

    - 데이터가 계층적 또는 네트워크 형태로 배치된 구조

    - ex) 트리(Tree), 그래프(Graph)

- 자료구조는 문제 해결의 핵심 도구로, 사용된 자료구조에 따라 선택 가능한 알고리즘이 달라질 수 있다. 따라서 적합한 자료구조를 선택하는 것이 곧 문제 해결 방법의 기본이자 출발점이라고 할 수 있다.

  - ex) BFS - 큐(Queue)

  - ex) 다익스트라 - 우선순위 큐(Priority Queue)

### 알고리즘

- 문제를 해결하는 방법 혹은 어떠한 문제를 해결하기 위해 정해진 일련의 절차나 방법

- 자주 쓰이는 문제 해결 방법(알고리즘)은 패턴화 → BFS, DFS, DP, 다익스트라

## 시간 복잡도와 공간 복잡도

시간 복잡도 

- 입력의 크기에 따른 프로그램 실행 시간

- 입력의 크기에 따른 연산 횟수

- 입력에 따른 실행 시간의 척도

- 내가 작성한 알고리즘이 입력값에 따라서 어느정도의 시간이 걸릴지 계산하는 방법

- 빅 오 표기법 (Big O)

  - 함수의 점근적 상항을 표기하는 방법
 
  - 입력 크기 n 이 커질 때, 코드의 실행 시간이나 성능이 어떻게 변화하는지를 대략적으로 예측하는 방법
 
  <img width="746" height="60" alt="image" src="https://github.com/user-attachments/assets/c2fb3e2c-151e-4d57-b09e-50cb02826496" />

  - n이 커질 때 실행 시간에 가장 큰 영향을 미치는 최고차항만 남기고 나머지 항은 모두 무시한다.


공간 복잡도

- 프로그램이 실행되었을 때 필요한 메모리 자원의 양

- 입력에 따른 메모리 사용량의 척도 
  
- 내가 작성한 알고리즘이 입력값에 따라서 어느 정도의 메모리를 사용하는지 계산하는 방법

# 2. 배열과 연결 리스트

## 배열

- 배열 : 일정한 메모리 공간을 차지하는 여러 요소들이 순차적으로 나열된 자료구조

- 각 요소에는 0부터 시작하는 고유한 순서 번호인 인덱스(index)가 매겨진다.

- 인덱스를 바탕으로 배열의 특정 요소에 접근하는 시간 → O(1)

- 인덱스를 바탕으로 특정 요소를 수정하는 시간 → O(1)

- 인덱스 차례대로 특정 요소가 있는지를 찾는 연산 → O(N)

  - 0번 인덱스, 1번, 2번.. 원하는 데이터를 찾을 때까지 하나씩 배열의 인덱스를 탐색
 
- 특정 인덱스의 요소를 추가하는 연산 → O(N)

- 특정 인덱스의 요소를 삭제하는 연산 → O(N)
  
## 연결리스트 (Linked List)

- 데이더틀 노드(Node)라는 개별 단위로 저장하며, 각 노드는 다음 노드의 주소를 가리키는 포인터를 가지고 있는 자료구조

- 배열과 달리, 메모리 상에서 물리적으로 연속적이지 않지만, 각 노드가 다른 노드의 메모리 주소를 저장함으로써 **논리적인 연속성**을 유지한다.

- 이로 인해 메모리 효율적으로 동작할 수 있으며, 데이터 삽입/삭제에서 뛰어난 성능을 발휘한다.

- 연속적으로 구성되어 있는 데이터를 불연속적으로 저장할 때 유용하게 사용한다.

- 연결리스트에서 특정 요소에 접근할 때는 앞에서부터 순차적으로 접근 : O(n)

- 중간에 요소를 추가하거나 삭제할 때 재정렬이 불필요해서 노드의 위치만 바꿔 저장 : O(1) - 노드에 접근하는 시간 동일

### 싱글 연결 리스트

- 각 노드는 하나의 Next 포인터만 가지며, 다음 노드를 가리킨다.

- 단방향으로만 이동이 가능하며, 구조가 단순하다.

- 특정 노드를 통해 '다음 노드'의 위치만 알 수 있고, '이전 노드'의 위치는 알기 어렵다.

### 이중 연결 리스트

- 각 노드는 Next 포인터와 Prev 포인터를 가지며, 다음 노드와 이전 노드 모두를 가리킬 수 있다.

- 양방향 이동이 가능해, 탐색과 삽입/삭제가 더 유연하다.

- 한 노드에 2개의 위치 정보(메모리 주소)를 저장해야 하므로 그만큼의 저장 공간이 더 필요하다.

### 환형 연결 리스트

- 마지막(꼬리) 노드가 첫 번째(헤드) 노드를 가리키는 구조로, 순환형 형태를 띈다.

- 시작과 끝이 연결된 형태로 데이터를 관리한다.

- 이중 연결 리스트로도 환형 연결 리스트를 구현할 수 있다.

- 모든 노드 데이터를 여러 차례 순회해야할 때, 유용하게 활용할 수 있다.

# 3. 스택과 큐

## 스택 

- 데이터를 저장하는 선형 자료구조, 후입선출(LIFO, Last In First Out)

- Push: 데이터를 스택의 맨 위(top)에 추가하는 연산.

- Pop: 데이터를 스택의 맨 위(top)에서 제거하고 반환하는 연산.

- 최근에 임시 저장한 데이터를 가장 먼저 활용해야하는 대표적인 상황 : 함수의 매개변수를 저장하기 위해 스택을 사용

## 큐

- 데이터를 저장하는 선형 자료구조로, 선입선출(FIFO, First In First Out) 방식

- enqueue(): 데이터를 큐의 뒤(rear)에 추가하는 작업

- dequeue(): 큐의 앞(front)에서 데이터를 꺼내는 작업

- 임시 저장된 데이터를 차례차례 내보내거나 꺼내 와야 하는 각종 버퍼 **버퍼**로도 활용된다. 즉, 줄 세우기에 자주 사용된다.

-  ``BFS 구현`` : 그래프 탐색 방식 중 하나인 BFS(Breadth-First Search)에서 queue는 핵심적인 역할을 한다.

    BFS는 특정 정점에서 시작해, 현재 정점에 인접한 정점들을 큐에 저장하고, 큐의 front에서 데이터를 dequeue하면서 모든 정점을 방문한다.

- ``투 포인터 사용`` : 투 포인터(Two Pointer) 알고리즘은 두 개의 포인터 위치를 기록하여 효율적으로 문제를 해결하는 방식. 큐를 활용하면 투 포인터 알고리즘을 보다 쉽게 구현할 수 있다.

- ``시뮬레이션/구현 문제`` : 현실 세계의 절차적 시스템(예: 인쇄 대기열, 캐시 시스템, 병원 접수 등)을 구현하는 문제에서는 Queue 자료구조를 활용한 FIFO(First-In-First-Out) 방식이 매우 효과적. 

  이러한 문제들은 상태가 시간의 흐름에 따라 변화하며, 각 이벤트를 순서대로 처리해야 하므로 큐를 이용해 자연스럽게 흐름을 재현할 수 있다.

- 종류 : 원형 큐, 덱, 우선순위 큐

  - 덱 (deque) : 양방향 큐, 양쪽으로 데이터를 삽입/삭제할 수 있는 큐, ``ArrayDeque``
 
  - 우선 순위 큐 (priority queue) : 저장된 요소들이 선입선출로 처리되는 것이 아니라, 정해진 우선순위가 높은 순으로 처리되는 큐
 
    - 힙(heap)이라는 자료구조를 기반으로 구현된다.         


# 4. 해시 테이블

- 데이터를 효율적으로 저장하고 검색하기 위한 자료구조

- 해시 함수를 활용하여 (key, value) 데이터를 저장한다.

  - key (키) : 해시 테이블에 대한 입력
 
  - value (값) : 키를 통해 얻고자 하는 데이터

- 즉, 해시 테이블에서는 문자열 key 값을 해시 함수(hash function)를 통해 정수 index로 변환하여 저장하므로, 다양한 key 값을 처리할 수 있다.

- 해시 테이블은 운영체제 내부에서도 자주 사용된다.

  - 페이지 캐시, 아이노드 캐시 등으로 활용

## 해시함수

해시함수 : 임의의 길이를 지닌 데이터를 고정된 길이의 데이터로 변환하는 단방향 함수

해시함수의 연산 방법 : 해시 알고리즘 ex) MD5, SHA-256 등

### 해시테이블의 동작원리

1. 해시함수 (Hash Function)
  
    - 해시 함수 h는 key 값을 받아 테이블의 index로 변환한다.
  
    - h(k)를 “key $k$의 해시값”이라고 부른다.
  
    - 즉, 실제 테이블에 저장되는 데이터의 위치는 key 값 k가 아닌, key k의 해시값 h(k)에 의해 결정된다.
  
    - 따라서 해시 함수 h가 key를 효율적으로 특정 index로 매핑하는 역할을 한다.
  
2. 슬롯 (Slot) 또는 버킷 (Bucket)

    - 해시 테이블에서 데이터를 저장하는 각각의 공간을 slot 또는 bucket이라고 부른다.
  
    - 각 bucket에는 특정 index에 대응되는 (key, value) 데이터 쌍이 저장된다.

<img width="1410" height="680" alt="image" src="https://github.com/user-attachments/assets/57c0f12b-bb64-4f9a-bdaf-8a5f591e3337" />

 - 해시 테이블에 저장된 데이터수 / 버킷의 수 = 로드 팩터 (load factor)

 - 로드 팩터는 해시 테이블이 현재 얼마나 가득 차 있는지에 대한 지표, 클수록 해시 테이블의 성능이 떨어진다.

- 해시 함수를 이용한 해시 값은 비밀번호를 저장할 때도 사용된다.

- 비밀번호를 비롯한 개인정보가 웹사이트에 저장될 때는 단방향 암호화(해시 함수 적용)를 통해 저장되도록 규제하고 있기 때문이다.

- 비밀번호 암호화 용도로 사용되는 대표적인 해시 함수 : bcyrpt, PBKDF2, scrypt, argon2 등

- 로그인 및 회원 정보 저장 기능을 제공하는 웹 프레임워크

  - Java : BCryptPasswordEncoder
 
  - Python : PASSWORD_HASHERS

- 모듈러 연산(나머지를 구하는 연산)을 이용한 간단한 해시 함수

  - A mod B : A를 B로 나눈 나머지 ex) 10 mod 3 = 1, 20 mod 8 = 4

  - 키가 k이고, 해시 테이블의 크기가 m일 때, h(k)는 k mod m 이라는 뜻이다.
 
  - 간단하게 해시 함수를 구현하게 되면 해시 충돌의 문제가 발생할 여지가 높아지기 때문에, 실제 해시 테이블에 사용되는 해시 함수가 간단한 경우는 드물다.
 
- 해시 테이블을 사용하는 이유? → **빠른 검색 속도**

  - 해시테이블을 활용한 검색, 삽입, 삭제 연산의 시간 복잡도 = O(1)

  - 해시테이블의 단점 → 속도가 빠른만큼, 많은 메모리 공간이 소모됨
 
## 해시 충돌 (hash collision)

- 해시 충돌
  
  - 서로 다른 key 값이 동일한 해시값을 가질 떄 발생하는 상황 

  - 2개 이상의 키에 같은 데이터가 대응되는 상황
    
- 즉, key 값 자체는 중복이 없지만, 해시 함수 h(k)가 반환하는 값이 중복되어 동일한 index에 저장하려고 할 때 충돌이 발생.

  <img width="2478" height="1274" alt="image" src="https://github.com/user-attachments/assets/ac105dc2-e656-40c5-8f6e-2d48b6495bae" />

### 해시 충돌 해결방법 (체이닝, 개방 주소법, 이중 해싱)

### 1. 체이닝 (chaining)

- 충돌이 발생한 데이터를 연결 리스트로 추가하는 방법

- 하나의 테이블에 인덱스에 여러 데이터가 연결 리스트의 노드로써 존재할 수 있다.

- 구현은 단순하지만, 충돌이 발생할 때마다 연결 리스트의 노드가 추가된다면 빠른 속도라는 해시 테이블의 장점을 살리지 못할 수도 있다.

- 극단적인 예시) n개의 데이터에 대해 모든 데이터가 충돌하는 경우, 탐색의 성능이 O(n)으로 떨어지게 된다.

### 2. 개방 주소법 (open addressing)

- 충돌이 발생했을 때, 충돌이 발생한 버킷의 인덱스가 아닌 다른 인덱스에 데이터를 저장하는 방법

- 즉, 자리 없는 인덱스를 피해 다른 인덱스를 알아보자!

- **조사 (probe)** : 충돌이 발생했을 때, 비어 있는 다른 버킷의 인덱스를 찾는 과정

  - 선형 조사법 (linear probing)

    - 충돌이 발생했을 때, 충돌이 발생한 인덱스의 다음 인덱스부터 순차적으로 가용한 인덱스를 찾아 나서는 방법
   
    - 해시함수 f, 키 key일 때 : 해시 값인 f(key)에서 충돌이 발생한다면 f(key) + 1, f(key) + 2, f(key) + 3, ...의 순으로 가용한 인덱스를 찾는 방식
 
  - 군집화 (clustering)
 
    - 해시 충돌이 발생하는 인덱스 인근에 충돌이 발생한 여러 데이터가 몰려 저장되는 현상
   
    - 군집화 현상은 오랜 순차 탐색이 필요해 성능 악화로 이어질 수 있다.

  - 이차 조사법 (quadratic probing)
  
    - 선형 조사법의 문제를 완화하는 방법
   
    - 충돌이 발생했을 때, 충돌이 발생한 인덱스에서 제곱수만큼 떨어진 거리에 위치한 인덱스를 찾는 방법
   
    - f(key) + 1^2, f(key) + 2^2, f(key) + 3^2, ...의 순으로 가용한 버킷 인덱스를 찾는다.
   
### 3. 이중 해싱 (double hasing)

- 2개의 해시 함수를 사용하는 방법

- 충돌이 발생했을 때, 다른 해시 함수(보조 해시 함수)에 대한 해시 값만큼 떨어진 거리에 위치한 인덱스를 찾는 방법

- 즉, 충돌이 발생하면 f(key) + g(key)에서 인덱스를 찾고,

  여기서도 충돌이 발생하면 f(key) + 2g(key), f(key) + 3g(key),...의 순으로 인덱스를 찾는다.

- 이렇게 해시 함수를 통해 무작위로 인덱스가 생성될 수 있다면 선형 조사법의 군집화 문제를 상당 부분 피할 수 있게 된다.

<hr>

### 프로그래밍 언어에서 해시 테이블을 지원하는 경우

|프로그래밍 언어|해시 테이블의 구현|
|------|-------|
|C++|unordered_map|
|자바|HashTable, HashMap|
|파이썬|dictionary|
|자바스크립트|Map|
|Go|map|
 
