# 1. 자료구조의 큰 그림

## 자료구조와 알고리즘

### 자료구조 

- 데이터를 저장하고 관리하는 방식
  
- 어떤 자료구조를 사용하느냐에 따라서 사용할 수 있는 알고리즘이 정해지는 경우가 많다.
  
  - ex) BFS - 큐 / 재귀 - 스택 / 다익스트라 - 우선순위큐 등
    
  - 자료구조의 선택에 따라 알고리즘의 성능과 효율성이 크게 달라질 수 있다. 
  
- 자료구조는 데이터를 효율적으로 저장하고 관리하는 방식을 의미한다. 

- 프로그램에서 데이터를 정리하고 저장하는 방법은 문제를 해결하는 데 있어서 중요한 역할을 한다.

- 적절한 자료구조를 사용하면 알고리즘의 성능과 효율성을 극대화할 수 있다.

- 자료구조는 크게 선형 자료구조와 비선형 자료구조로 구분된다.

  - 선형 자료구조
  
    - 데이터가 일렬로 배치되어 순서대로 접근 가능한 구조

    - ex) 배열(Array), 연결리스트(Linked List), 스택(Stack), 큐(Queue), 우선순위큐(Priority queue)

  - 비선형 자료구조

    - 데이터가 계층적 또는 네트워크 형태로 배치된 구조

    - ex) 트리(Tree), 그래프(Graph)

- 자료구조는 문제 해결의 핵심 도구로, 사용된 자료구조에 따라 선택 가능한 알고리즘이 달라질 수 있다. 따라서 적합한 자료구조를 선택하는 것이 곧 문제 해결 방법의 기본이자 출발점이라고 할 수 있다.

  - ex) BFS - 큐(Queue)

  - ex) 다익스트라 - 우선순위 큐(Priority Queue)

### 알고리즘

- 문제를 해결하는 방법 혹은 어떠한 문제를 해결하기 위해 정해진 일련의 절차나 방법

- 자주 쓰이는 문제 해결 방법(알고리즘)은 패턴화 → BFS, DFS, DP, 다익스트라

## 시간 복잡도와 공간 복잡도

시간 복잡도 

- 입력의 크기에 따른 프로그램 실행 시간

- 입력의 크기에 따른 연산 횟수

- 입력에 따른 실행 시간의 척도

- 내가 작성한 알고리즘이 입력값에 따라서 어느정도의 시간이 걸릴지 계산하는 방법

- 빅 오 표기법 (Big O)

  - 함수의 점근적 상항을 표기하는 방법
 
  - 입력 크기 n 이 커질 때, 코드의 실행 시간이나 성능이 어떻게 변화하는지를 대략적으로 예측하는 방법
 
  <img width="746" height="60" alt="image" src="https://github.com/user-attachments/assets/c2fb3e2c-151e-4d57-b09e-50cb02826496" />

  - n이 커질 때 실행 시간에 가장 큰 영향을 미치는 최고차항만 남기고 나머지 항은 모두 무시한다.


공간 복잡도

- 프로그램이 실행되었을 때 필요한 메모리 자원의 양

- 입력에 따른 메모리 사용량의 척도 
  
- 내가 작성한 알고리즘이 입력값에 따라서 어느 정도의 메모리를 사용하는지 계산하는 방법

# 2. 배열과 연결 리스트

## 배열

- 배열 : 일정한 메모리 공간을 차지하는 여러 요소들이 순차적으로 나열된 자료구조

- 각 요소에는 0부터 시작하는 고유한 순서 번호인 인덱스(index)가 매겨진다.

- 인덱스를 바탕으로 배열의 특정 요소에 접근하는 시간 → O(1)

- 인덱스를 바탕으로 특정 요소를 수정하는 시간 → O(1)

- 인덱스 차례대로 특정 요소가 있는지를 찾는 연산 → O(N)

  - 0번 인덱스, 1번, 2번.. 원하는 데이터를 찾을 때까지 하나씩 배열의 인덱스를 탐색
 
- 특정 인덱스의 요소를 추가하는 연산 → O(N)

- 특정 인덱스의 요소를 삭제하는 연산 → O(N)
  
## 연결리스트 (Linked List)

- 데이더틀 노드(Node)라는 개별 단위로 저장하며, 각 노드는 다음 노드의 주소를 가리키는 포인터를 가지고 있는 자료구조

- 배열과 달리, 메모리 상에서 물리적으로 연속적이지 않지만, 각 노드가 다른 노드의 메모리 주소를 저장함으로써 **논리적인 연속성**을 유지한다.

- 이로 인해 메모리 효율적으로 동작할 수 있으며, 데이터 삽입/삭제에서 뛰어난 성능을 발휘한다.

- 연속적으로 구성되어 있는 데이터를 불연속적으로 저장할 때 유용하게 사용한다.

- 연결리스트에서 특정 요소에 접근할 때는 앞에서부터 순차적으로 접근 : O(n)

- 중간에 요소를 추가하거나 삭제할 때 재정렬이 불필요해서 노드의 위치만 바꿔 저장 : O(1) - 노드에 접근하는 시간 동일

### 싱글 연결 리스트

- 각 노드는 하나의 Next 포인터만 가지며, 다음 노드를 가리킨다.

- 단방향으로만 이동이 가능하며, 구조가 단순하다.

- 특정 노드를 통해 '다음 노드'의 위치만 알 수 있고, '이전 노드'의 위치는 알기 어렵다.

### 이중 연결 리스트

- 각 노드는 Next 포인터와 Prev 포인터를 가지며, 다음 노드와 이전 노드 모두를 가리킬 수 있다.

- 양방향 이동이 가능해, 탐색과 삽입/삭제가 더 유연하다.

- 한 노드에 2개의 위치 정보(메모리 주소)를 저장해야 하므로 그만큼의 저장 공간이 더 필요하다.

### 환형 연결 리스트

- 마지막(꼬리) 노드가 첫 번째(헤드) 노드를 가리키는 구조로, 순환형 형태를 띈다.

- 시작과 끝이 연결된 형태로 데이터를 관리한다.

- 이중 연결 리스트로도 환형 연결 리스트를 구현할 수 있다.

- 모든 노드 데이터를 여러 차례 순회해야할 때, 유용하게 활용할 수 있다.

# 3. 스택과 큐

## 스택 

- 데이터를 저장하는 선형 자료구조, 후입선출(LIFO, Last In First Out)

- Push: 데이터를 스택의 맨 위(top)에 추가하는 연산.

- Pop: 데이터를 스택의 맨 위(top)에서 제거하고 반환하는 연산.

- 최근에 임시 저장한 데이터를 가장 먼저 활용해야하는 대표적인 상황 : 함수의 매개변수를 저장하기 위해 스택을 사용

## 큐

- 데이터를 저장하는 선형 자료구조로, 선입선출(FIFO, First In First Out) 방식

- enqueue(): 데이터를 큐의 뒤(rear)에 추가하는 작업

- dequeue(): 큐의 앞(front)에서 데이터를 꺼내는 작업

- 임시 저장된 데이터를 차례차례 내보내거나 꺼내 와야 하는 각종 버퍼 **버퍼**로도 활용된다. 즉, 줄 세우기에 자주 사용된다.

-  ``BFS 구현`` : 그래프 탐색 방식 중 하나인 BFS(Breadth-First Search)에서 queue는 핵심적인 역할을 한다.

    BFS는 특정 정점에서 시작해, 현재 정점에 인접한 정점들을 큐에 저장하고, 큐의 front에서 데이터를 dequeue하면서 모든 정점을 방문한다.

- ``투 포인터 사용`` : 투 포인터(Two Pointer) 알고리즘은 두 개의 포인터 위치를 기록하여 효율적으로 문제를 해결하는 방식. 큐를 활용하면 투 포인터 알고리즘을 보다 쉽게 구현할 수 있다.

- ``시뮬레이션/구현 문제`` : 현실 세계의 절차적 시스템(예: 인쇄 대기열, 캐시 시스템, 병원 접수 등)을 구현하는 문제에서는 Queue 자료구조를 활용한 FIFO(First-In-First-Out) 방식이 매우 효과적. 

  이러한 문제들은 상태가 시간의 흐름에 따라 변화하며, 각 이벤트를 순서대로 처리해야 하므로 큐를 이용해 자연스럽게 흐름을 재현할 수 있다.

- 종류 : 원형 큐, 덱, 우선순위 큐

  - 덱 (deque) : 양방향 큐, 양쪽으로 데이터를 삽입/삭제할 수 있는 큐, ``ArrayDeque``
 
  - 우선 순위 큐 (priority queue) : 저장된 요소들이 선입선출로 처리되는 것이 아니라, 정해진 우선순위가 높은 순으로 처리되는 큐
 
    - 힙(heap)이라는 자료구조를 기반으로 구현된다.         


# 4. 해시 테이블
