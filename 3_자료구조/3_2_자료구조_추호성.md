# 5. 트리

- 트리란, 노드와 간선으로 구성된 방향성을 가진 계층적 자료구조

- 노드간의 관계에 기반하여 부모, 자식, 형제, 조상, 자손, 루트, 리프 노드라는 개념이 존재한다.
- 트리의 높이에 기인하여 차수, 레벨, 깊이라는 개념이 존재한다.
- 트리는 포함관계를 가질 수 있다. 트리 내부의 트리를 서브트리라고 한다.
- 트리는 그림 상 복잡해보이지만, 메모리에 (데이터 + 자식 노드 주소) 형태로 단순하게 저장된다.

## 트리의 순회

트리의 순회

- 트리 내 모든 노드를 한 번 씩 방문하는 행위다.

- 다양한 트리 순회 방법이 존재한다.

전위 순회

- 본인 → 왼쪽 자식 → 오른쪽 자식 순서로 순회하는 방식을 의미한다.

- 자식 노드에 대해 재귀적으로 순회한다.
- 다음과 같은 코드로 나타낼 수 있다.
    
    ```java
    preOrder(node):
    	if node is null:
    		return
    	
    	print(node)
    	preOrder(node.left)
    	preOrder(node.right)
    ```
    

중위 순회

- 왼쪽 자식 → 본인 → 오른쪽 자식 순서로 순회하는 방식이다.

- 마찬가지로 자식 노드에 대해 재귀적으로 순회한다.
- 다음과 같은 코드로 나타낼 수 있다.
    
    ```java
    inOrder(node):
    	if node is null:
    		return
    	
    	inOrder(node.left)
        print(node)
    	inOrder(node.right)
    ```
    

후위 순회

- 왼쪽 자식 → 오른쪽 자식 → 본인 순서로 순회하는 방식을 의미한다.
- 자식 노드에 대해 재귀적으로 순회한다.
- 다음과 같은 코드로 나타낼 수 있다.
    
    ```java
    inOrder(node):
    	if node is null:
    		return
    	
    	inOrder(node.left)
    	inOrder(node.right)
    	print(node)
    ```
    
<img width="720" height="311" alt="image" src="https://github.com/user-attachments/assets/d3285398-3c62-41cb-95f4-0b309aa82527" />

레벨 순서 순회

- 레벨 별 노드를 순회하는 방식을 의미한다.

- 주로 큐를 이용하여 BFS 방식으로 구현한다. 레벨 별로 분류하고 싶다면, size 변수를 추가한다.

## 트리의 종류

- 이진 트리

    - 자식 노드의 개수가 2개 이하인 트리

- 편향된 이진 트리

    - 모든 자식 노드가 한쪽으로 치우친 이진 트리

    - 탐색 과정에서 비효율을 가져온다.

- 정 이진 트리

    - 자식 노드의 개수가 1개가 아닌 이진 트리

- 포화 이진 트리

    - 리프 노드를 제외한 모든 노드들이 2개의 자식 노드를 가지고 있는 이진 트리

    - 모든 리프 노드의 레벨이 동일한 이진 트리

- 완전 이진 트리

    - 마지막 레벨을 제외한 모든 레벨이 2개의 자식 노드를 가진다.

    - 마지막 레벨의 모든 노드들이 왼쪽부터 존재하는 이진 트리

    - 주로 힙(우선순위 큐)에서 사용된다.
      
<img width="591" height="203" alt="image" src="https://github.com/user-attachments/assets/4c9c7151-c4c7-4c5e-9162-ea945d290cbd" />

탐색에 사용되는 트리

- 이진 탐색 트리

    - 이진 트리 형태에서 왼쪽 자식엔 작은 값을, 오른쪽 자식에는 큰 값을 저장하는 방식

    - 삽입, 삭제, 탐색이 O(logN) 을 가진다.

    - 편향된 이진 트리가 될 경우 O(N)으로 비용이 증가할 수 있다.

- 힙(우선순위 큐)

    - 완전 이진 트리의 일종이다.

    - 추출, 삽입, 삭제는 O(logN)이다. (탐색 자체는 O(1))

    - 최대, 최소 값을 빠르게 찾기 위해 사용된다.

    - 특히 N개의 데이터를 입력하는 중 K개의 최대, 최소 값을 추출하는데 유용하다.

- AVL 트리

    - AVL 트리는 자가 균형 이진 탐색 트리의 일종

    - 노드 삽입/삭제 후 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1을 넘지 않도록 유지

    - 만약 차이가 2 이상으로 벌어지면, 트리를 회전을 통해 리밸런싱한다.

    - 리밸런싱에는 LL, LR, RL, RR 회전이 있다.
 
      <img width="280" height="180" alt="image" src="https://github.com/user-attachments/assets/c704ebc5-cf75-428c-9fd4-f1529b81c441" />


- RB 트리

    - 노드에 색을 칠하는 규칙과 칠해진 색을 기준으로 서브트리간 높이 균형을 맞추는 방식이다.

    - 규칙은 다음과 같다.

        - 루트 노드, 리프 노드는 블랙 노드다.(리프 노드는 NIL이라고 하며, NULL 형태다)

        - 레드 노드의 자식은 블랙 노드다.

        - 루트 노드에서 임의의 리프 노드에 이르는 경로의 블랙 노드 수는 같다.

    - 해당 규칙이 지켜질 때 까지 트리를 회전하거나 색상을 지정해야 한다.
      
<img width="1280" height="627" alt="image" src="https://github.com/user-attachments/assets/b6397fcd-a22e-478b-837f-59cca1253904" />


- B 트리
    - 하나의 노드가 3개 이상의 자식을 가질 수 있는 다진 탐색 트리다. N개의 자식 노드를 가지는 경우, N차 B 트리라고 부른다.

    - 각 노드에는 하나 이상의 키 값이 존재하고, 각 키들이 오름차순을 가진다.

    - 모든 리프 노드의 깊이가 같다.(노드를 분할해야 할 경우, 부모 노드로 값을 올리기 때문)

    - 파일 시스템, 데이터베이스와 같은 대용량 저장 장치에 값을 저장하는데 사용된다.

- B+ 트리
    - B 트리와 유사하지만, 몇 가지 차이점을 가진다.

    - 실질적인 데이터가 모두 최하위 리프 노드에 위치해있다.

    - 스플릿 노드는 B 트리처럼 분리되는데, 리프 노드는 중복돼서 분리된다(자세한건 visualization 참조)

    - 최하위 노드는 모두 연결 리스트 형태를 가진다.

# 6. 그래프

- 연결 관계를 표현하는 자료구조다.

- 다양한 종류가 존재하며, 트리도 그래프의 일종이다.

## 그래프의 종류와 구현

그래프의 정의와 종류

- 그래프는 정점을 간선으로 연결한 형태의 자료구조다.

- 그래프는 옵션에 따라 다양한 특징을 가진다. 연결/비연결, 유향/무향, 가중치, 서브그래프 등이 존재한다.
- 이중, 서브그래프는 서브 트리와 같이 원본 그래프의 일부 정점과 간선만을 이용한 그래프를 의미한다.

그래프의 표현법

- 그래프는 인접 행렬과 인접 그래프로 표현할 수 있다.

- 인접 행렬

    - 이차원 배열을 기반으로 하며, 배열의 인덱스를 정점, 배열의 값을 간선 가중치로 설정한다.

    - 인접 그래프에 비해 빠른 접근 속도를 가지지만, 많은 저장 비용을 사용한다는 단점이 있다.
    - 정점의 수가 많지 않고, 간선의 양이 많은 경우 유리하다.
      
- 인접 그래프
    - 연결 리스트를 기반으로 하며, 정점과 간선 가중치를 연결 리스트의 노드에 저장한다.

    - 인접 행렬에 비해 저장 비용이 효율적이지만 접근 속도가 상대적으로 느리다는 단점이 있다.

## DFS와 BFS

깊이 우선 탐색(DFS)

- 그래프에서 더 이상 방문 가능한 정점이 없을 때까지 최대한 깊이 탐색하기를 반복하는 탐색 방법

- 방문 여부를 확인하는 배열 + 스택(혹은 재귀함수)을 이용한다.

너비 우선 탐색(BFS)

- 인접한 모든 정점들을 방문하는 탐색 방법. 가까운 정점부터 확인한다.

- 방문 여부를 확인하는 배열 + 큐를 이용한다.

## 최단 경로 알고리즘

- 특정 정점 사이의 가장 짧은 경로를 알려주는 알고리즘을 의미한다.

- 다익스트라, 마샬, 벨만-포드 등 여러 알고리즘이 존재한다.

다익스트라 알고리즘

- 특정 정점에서 다른 모든 정점까지의 최단 거리를 구하는 알고리즘이다.

- 간선의 가중치가 음이 아닌 수라는 가정 하에 사용된다.
- 특정 정점에서 다른 모든 정점까지의 거리가 저장된 테이블(최단 거리 테이블) + 방문 여부를 확인하는 배열을 이용한다.

다익스트라 알고리즘 흐름

1. 최단 거리 테이블을 충분히 큰 수로 초기화 한다.(본인은 0으로 초기화 한다)

2. 정점을 방문한다.
3. 방문한 정점과 인접한 정점을 탐색한다.
4. 인접한 정점까지의 누적 거리를 최단 거리 테이블 값과 비교한 뒤, 더 작을 경우 갱신한다.
5. 방문하지 않은 정점 중 최단 거리가 가장 작은 정점으로 방문한다.(방문 후 방문 표시를 한다)
6. 더 이상 방문할 정점이 없어질 때 까지 3~5를 반복하고 종료한다.
7. 최단 거리 테이블을 이용하여 원하는 정점까지의 최소 거리를 구할 수 있다.

`O(V^2 + E)` → **`O(V^2)`** (보통 E ≤ V²)

힙을 이용한 다익스트라 알고리즘

- 최단 거리 테이블을 충분히 큰 수로 초기화 한다.

- 가중치를 중심으로 하는 최소 힙에 (본인 정점, 0)을 입력한다.
- 최소 힙을 dequeue한 뒤 최단 거리 테이블을 변경한다.(단, dequeue된 값이 최단 거리 테이블 내의 값보다 큰 경우 무시한다)
- 인접한 정점을 탐색한 뒤, (인접한 정점, 누적 거리)를 최소 힙에 입력한다.
- 최소 힙이 빌 때 까지 반복한다.

**`O(E log V)`** (희소 그래프에서 E > V)

- RB 트리 공부하기

- 이미지 자료 첨부하기
