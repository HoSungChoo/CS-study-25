# 1. 컴퓨터 구조의 큰 그림

## 컴퓨터가 이해하는 정보

- 컴퓨터는 CPU를 기반으로 데이터와 명령어만을 이해하고 처리한다.

- 명령어에 따라 CPU의 데이터 처리가 달라지며, 이는 데이터가 명령어에 종속적임을 알 수 있다.

## 컴퓨터의 핵심 부품

- 컴퓨터는 CPU, 메모리, 캐시 메모리, 보조기억장치, 입출력장치로 구성되어 있다.

### CPU

명령어와 데이터를 읽고, 해석하고, 실행하는 역할을 한다.

CPU의 주요 구성 요소와 명령어의 신속한 처리를 위한 기술을 이해해야 한다.

CPU의 주요 구성 요소는 다음과 같다.

- 산술논리연산장치
    - 사칙 연산, 논리 연산을 담당한다.

    - 즉, 계산을 담당한다.

- 제어장치
    - 명령어를 해석하고 대상 부품에 신호를 보내는 역할을 한다.

- 레지스터
    - CPU 내부의 임시 저장장치다.

    - 데이터와 명령어를 처리하는 과정의 중간값을 저장한다.

    - 여러 개의 레지스터가 존재하며, 각각 다른 역할을 한다.

### 메모리와 캐시 메모리

- 메모리는 CPU가 명령어와 데이터를 읽고 해석하고 실행하는 과정에서 정보를 저장하는 역할을 한다.

- 현재 실행 중인 프로그램을 구성하는 데이터와 명령어를 저장하는 부품이다.
- 주소라는 개념이 존재하며, 휘발성이라는 특징을 가진다.
- 캐시 메모리는 CPU가 빠른 메모리 접근을 하기 위해 사용된다.
- 여러 종류가 존재하며, CPU 안과 밖에 위치한다.

### 보조기억장치

- 비휘발성 저장장치로 SSD, HDD가 주로 존재한다.

- 데이터를 보관하는 역할을 한다.
- CPU가 보조기억장치에 존재하는 데이터에 접근하려면 무조건 메모리에 복사한 뒤 사용해야 한다.

### 입출력 장치

- 컴퓨터 외부에 연결되어 내부와 정보를 교환하는 장치다.

- 마우스, 키보드, 스피커 등이 존재한다.
- 보조기억장치와 함께 주변장치라고 통칭한다.

### 메인보드와 버스

- 메인보다는 각 부품들을 고정하고 연결하는 도화지 역할을 한다.

- 버스는 각 부품을 이어주며, 역할 수행을 위해 필요한 정보를 주고받는 통로 역할을 한다.

### 저장 장치의 계층 구조

<img width="636" alt="Screenshot 2025-06-24 at 4 58 02 PM" src="https://github.com/user-attachments/assets/8f901872-e18a-43a5-883f-ddcd72ae1587" />

### 컴퓨터구조 지도 그리기
![image (4)](https://github.com/user-attachments/assets/4236ffd0-578c-44bd-80e9-8e79217a1ca1)

# 2. 컴퓨터가 이해하는 정보

## 정보의 단위

- 비트 : 2의 8승까지 나타낼 수 있는 수의 범위

- 워드 : CPU가 한 번에 처리할 수 있는 단위. 32, 64비트가 존재

## 부동 소수점

- 소수를 이진수의 형태로 나타내는 방식이다.

- 현대에는 IEEE 754 방식을 따르고 있으며, 이는 `부호, 지수, 가수`로 구성된다. 32비트 체계에서는 (1, 8, 23)의 크기를 가지며, 64비트 체계에서는 (1, 11, 52)의 크기를 가진다.
- 12.345는 1100.0101100001010001… 라는 이진수로 변환된다. 이를 32비트 부동소수점으로 표현하면 다음과 같다.
    - 부호는 signed이므로 `0`으로 표현된다.

    - 지수는 1100 = 1.100 * 2^3 이므로 3일 수 있지만, 바이어스 값인 2^7 - 1이 더해지므로, 127 + 3 = 130 → `10000010`으로 표현된다.(바이어스는 2의 (지수 - 1) 제곱 크기를 가진다.)
    - 가수는 23비트로 소수점인 `10001011000010100011110`으로 표현된다.
    - 따라서 12.345는 이진수로 `0/10000010/10001011000010100011110` 값을 가진다.
    - 이진수는 길기 때문에 16진수로 표현할 수 있다. 이 경우 12.345는 `0x4145851E` 값으로 변경된다.
- 부동소수점은 요구하는 10진수 소수와 완전히 맞아떨어지지 않을 수 있다.
- 표현하고자 하는 수가 굉장히 작은 경우 어떻게 표현할 수 있을까? 표현하고자 하는 수가 2의 -127승보다 작은 경우, 가수에 숨겨진 1을 제외하고 표현한다.
- 표현하고자 하는 수가 굉장히 큰 경우 어떻게 표현할 수 있을까? 0/111../111… 과 같이 맨 앞을 제외한 모든 비트가 1인 수가 가장 큰 수고, 이 이상의 경우 INF 혹은 OVERFLOW 처리 된다.

## 문자 표현하기

- 개념
    - 컴퓨터가 이해할 수 있는 문자들의 집합을 문자 집합이라고 한다.

    - 문자를 01로 이루어진 문자코드로 변환하는 과정을 문자 인코딩, 01로 이루어진 문자코드를 문자로 변경하는 것을 문자 디코딩이라고 한다.

- 아스키 코드
    - 1바이트로 표현할 수 있는 문자 집합이다.

    - 1비트는 오류 검출을 위한 패리티 비트이기 때문에 128개의 문자만 표현할 수 있다.
    - 패리티 비트는 아스키 코드의 나머지 비트 중 1의 개수의 홀수일 경우 0, 짝수일 경우 1값을 가진다. 이는 오류 검출에 도움을 주지만, 오류 수정 불가 및 오류 감지 능력 부족이라는 한계점을 가진다.
    - 영어 이외의 언어 표현에 한계가 있다. → EUC-KR이 등장한다.
- EUC-KR
    - 2바이트(4자리 16진수)로 표현할 수 있는 문자 인코딩 방식이다.
    - KS x 1001, KS x 1003이라는 문자 집합을 기반한다.(특정 숫자에 대응되는 문자 데이터 셋이 존재한다)
    - 약 2300개의 한글 단어를 표현할 수 있지만, 모든걸 표현할 수 없다 → 유니코드가 등장한다.

- 유니코드
    - 다양한 언어, 특수문자, 이모티콘까지 표현할 수 있는 통일된 문자 집합이다.

    - 유니코드는 글자가 가지고 있는 고유 번호를 의미한다. 예를 들어, 😊은 **`128522`**값을 가진다. 그러나 이를 사용할 때, 해당 값을 적용하는 것이 아니라 다양한 방식으로 인코딩해 사용한다.
    - 인코딩 방식은 UTF-8, UTF-16, UTF-32 가 존재하며, 해당 방식은 모두 가변 길이 인코딩 방식이다. 특징은 다음과 같다.
        
        
        | 특징 | UTF-8 | UTF-16 | UTF-32 |
        | --- | --- | --- | --- |
        | 가변 길이 | ✔ (1~4바이트) | ✔ (2 or 4바이트) | ❌ (항상 4바이트) |
        | ASCII 호환 | ✔ (완전 호환) | ❌ | ❌ |
        | 공간 효율 | 영어 위주 텍스트에 효율적 | 한중일(동아시아) 텍스트에 효율적 | 가장 비효율적 (공간 낭비 큼) |
        | 처리 속도 | 느릴 수 있음 | 빠름 | 매우 빠름 (고정 길이) |
        | 사용 예시 | 웹, JSON, 이메일 등 | Windows 내부, Java | 일부 시스템 내부 전용 |
- 유니코드의 인코딩 방식
    - UTF-8
        - 모든 유니코드 값을 1 ~ 4 바이트(가변 길이)로 표현하는 방식이다. 가장 대중적이다.

        - 인코딩 데이터가 가변 길이인 경우, 어떻게 이를 읽나 ? → 비트 패턴을 분석하여 데이터의 길이를 유추한다.
        - 유니코드의 크기에 따라 바이트 크기를 선정하고, 그에 맞는 복잡한 수식을 이용하여 표현한다.
        - 인디안 문제에서 자유로움, 공간 효율성, 아스키 호환성, 범용성이 뛰어나다는 장점이 있다.
        - 아스키 호환성이 좋은 이유는 아스키에서 변환된 유니코드가 1바이트로 할당되기 때문에 변환에 유리하기 때문이다.
    - UTF-16
        - 모든 유니코드 값을 2, 4바이트(가변 길이)로 표현하는 방식이다.

        - 유니코드의 크기를 기준으로 U+10000을 넘어가면 4바이트로, 그렇지 않으면 2바이트로 표기한다.
        - 처리 속도와 공간 비용에서 균형을 이룬다.
        - 2 바이트를 사용하기 때문에 읽는 순서에서 문제가 발생할 수 있다.(인디안 문제) 이를 해결하기 위해 BOM을 이용한다.
        - BOM이란 문서 맨 앞에 눈에 보이지 않는 특정 바이트(byte)를 넣은 다음 이것을 해석해서 정확히 어떤 인코딩 방식이 사용되었는지 알아내는 방법이다.
    - UTF-32
        - 모든 유니코드 값을 4바이트로 표현하는 방식이다.

        - 고정 길이로 처리속도는 빠르지만, 많은 공간 비용이 발생한다.
    - 예를 들어, 문자 `가` 는 유니코드 U+AC00 로 표시할 수 있으며, 이를 다음과 같이 인코딩할 수 있다.
        - UTF-8 : `0xEA 0xB0 0x80`

        - UTF-16 : `0xAC00`
        - UTF-32 : `0x0000AC00`
    - 출처 : https://www.youtube.com/watch?v=GMF2Z1EZHXk

- BASE 64
    - 64진수를 통해 데이터를 인코딩하는 방식이다. 주로 이진 데이터를 인코딩하며, 이 외에도 문자, 이미지 등 다양한 데이터를 인코딩할 수 있다.

    - 아스키 코드(8비트)로 표현되는 64개의 문자로 6비트의 수를 표현한다. 이는 인코딩 데이터가 오히려 크기가 커질 수 있다는 단점이 있지만, 하나의 표준으로 안전하게 사용될 수 있다는 점, 텍스트 시스템에서 안전하게 사용할 수 있다는 장점이 있다.
    - 6비트로 데이터를 쪼갤 경우, 나머지가 생길 수 있는데, 이는 패딩처리한다.
    - 과정은 다음과 같다. `Man(문자열)` → `77 97 110(아스키 코드)` → `01001101 01100001 01101110(이진수)` → `010011 010110 000101 101110(6비트로 쪼갠 이진수)` → `TWFu(Base64)`

## 명령어

- 명령어는 연산 코드(수행할 동작) + 0개 이상의 오퍼랜드(수행할 대상)로 구성되어 있다.

- 오퍼랜드는 값 자체 혹은 주소가 될 수 있다. 대부분 주소가 사용되기 때문에 주소 필드라고 불린다.
- 연산 코드는 대표적으로 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어 명령으로 분류된다.

### 기계어와 어셈블리어

- 기계어는 컴퓨터가 이해할 수 있게 0과 1로 구성된 언어다.

- 어셈블리어는 기계어를 읽기 편한 형태로 단순 번역한 언어다. 같은 어셈블리어일지라도 CPU마다 이해하는 명령어가 다르면 실행이 불가능할 수 있다.

### 명령어 사이클

- 프로그램이 작동되기 위해선 CPU가 지속적으로 명령어를 실행해야 하는데, 이 주기를 명령어 사이클이라고 한다.

- 다음은 사이클 순서를 나타낸다.
    1. 먼저 명령어를 메모리에서 CPU로 가져와야 하는데, 이는 인출 사이클이다.(레지스터로 가져온다)

    2. CPU로 가져온 명령어를 실행하는 과정을 실행 사이클이라고 한다.
    3. 오퍼랜드에 값이 아닌 메모리 주소가 명시된 경우, 한번 더 메모리에 접근해야 한다. 이를 간접 사이클이라고 한다.
    4. 인터럽트를 처리하는 과정을 인터럽트 사이클이라고 한다.
    5. 명령어 사이클은 `인출 → (간접) → 실행 → 인출 → ..` 사이클이 반복되는 과정이다.

### CISC와 RISC

- CPU를 설계하는 방식이다.

- CISC
    - 명령어가 S/W 적인 방식이다.

    - 복잡하고 많은 종류의 명령어를 사용한다. 명령어가 가변 길이다.
    - 컴파일 과정이 쉽고, 호환성이 좋다는 장점이 있지만 속도가 느리다.
- RISC
    - 명령어가 H/W 적인 방식이다.

    - 간단하고 적은 종류의 명령어를 사용한다. 명령어 길이가 고정적이다.
    - 명령어 처리 속도가 빠르고 효율적이다. 그러나 하드웨어 종속적이다.

# 3. CPU

CPU 작동 과정은 다음을 참고하자.

https://www.youtube.com/watch?v=Fg00LN30Ezg(12:20부터)

## 레지스터

- CPU 안에 존재하는 작은 임시 저장 장치

- 프로그램 카운터
    - 메모리에서 다음으로 읽어 들일 명령어의 주소(명령어 포인터)를 저장한다.

    - 일반적으로 해당 값은 1씩 증가하는데, 특정 위치로 변경되는 경우가 존재한다.
- 명령어 레지스터
    - 메모리에서 읽어 들인 명령어를 저장한다.(연산 코드 + 오퍼랜드를 저장하는 듯한데 확인 필요)

    - 저장된 명령어는 CU를 통해 해석 → ALU를 통해 연산 or 제어 신호 전송을 통해 다른 부품을 작동
- 범용 레지스터
    - 다양한 상황에서 사용되는 레지스터다.

    - 데이터, 명령어, 주소 모두 저장할 수 있다.
    - CPU 안에는 여러 개의 범용 레지스터가 존재한다.
- 플래그 레지스터
    - 연산 결과에 대한 부가 정보, CPU 상태 정보를 저장하는 레지스터다.

    - 플래그 종류는 다음과 같다.
        
        
        | 종류 | 설명 | 0인 경우 | 1인 경우 |
        | --- | --- | --- | --- |
        | 부호 플래그 | 연산 결과의 부호 | 결과가 양수 | 결과가 음수 |
        | 제로 플래그 | 연산 결과의 0 여부 | 결과가 0이 아님 | 결과가 0 |
        | 캐리 플래그 | 연산 결과의 올림수 혹은 빌림수 발생 여부 | 발생 X | 발생 O |
        | 오버플로우 플래그 | 연산 결과에 오버플로우 발생 여부 | 발생 X | 발생 O |
        | 인터럽트 플래그 | CPU가 외부 인터럽스를 수용할 수 있는지에 대한 여부 | 불가능 | 가능 |
        | 슈퍼바이저 플래그 | 커널 모드, 사용자 모드 실행 여부(CPU 상태 정보) | 사용자 모드 | 커널 모드 |
- 스택 포인터
    - 메모리 위에서 실행중인 프로그램은 스택과 같은 형태로 사용 가능한 주소 공간을 하나 이상 가지고 있다.

    - 이를 스택 영역이라고 하는데, CPU의 스택 포인터는 메모리의 스택 영역 최상단 데이터 위치를 가리키고 있다.

## 인터럽트

- CPU 작업을 방해하는 신호를 의미한다.

- 동기, 비동기 인터럽트(하드웨어 인터럽트)로 나뉜다.
    - 동기 인터럽트(예외)는 CPU에 의해 발생하는 인터럽트며, 프로그래밍 오류와 같은 예외적인 상황을 마주했을 때 발생한다. 따라서 예외라고 부르기도 한다.

    - 비동기 인터럽트(하드웨어 인터럽트)는 주로 입출력 장치에 의해 발생한다. 작업 완료, 입력 알림과 같은 역할을 한다.
    - 즉, CPU 명령 자체에서 인터럽트가 발생할 경우 동기, 외부에서 유입될 경우 비동기다.

### 하드웨어 인터럽트

- 작업을 완료했음을 알람을 통해 CPU에게 알려주므로, CPU는 작업을 주기적으로 확인할 필요 없다 → CPU 자원 낭비를 줄일 수 있다.

- CPU가 하드웨어 인터럽트를 처리하는 순서는 다음과 같다
    1. 입출력 장치는 CPU에게 인터럽트 요청 신호를 전송

    2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 인터럽트 여부를 확인
    3. CPU는 인터럽트 요청을 확인하고, 인터럽트 플래그를 통해 인터럽트 수용 여부를 확인
    4. 인터럽트를 수용할 수 있다면, CPU가 지금까지 작업을 백업(보통 스택에 백업한다)
    5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
    6. 인터럽트 서비스 루틴이 끝나면 백업해둔 작업을 복구하여 실행

- 인터럽트 구성 요소
    - 인터럽트 요청 신호 : 입출력장치가 CPU로 보내는 인터럽트 신호

    - 인터럽트 플래그 : 인터럽트 수용 여부 결정. 그러나 무시할 수 없는 인터럽트도 존재(정전, 고장 등) → 막을 수 있는 인터럽트와 막을 수 없는 인터럽트로 분리된다.
    - 인터럽트 서비스 루틴 : 인터럽트에 따른 대응책 정보로 이루어진 프로그램이다. CPU는 인터럽트 서비스 루틴을 실행하고, 원래 작업으로 돌아온다.
    - 인터럽트 벡터 : ISR 주소 모음. 인터럽트는 인터럽트 벡터를 타고 ISR로 전송된다.

### 최종 CPU 명령어 사이클

![image (5)](https://github.com/user-attachments/assets/e55a7852-b262-4106-9396-34322d684b8c)

### 예외

- CPU 명령 실행 중 발생하는 예외 상황(0으로 나누기, OOM 등)을 의미한다. 동기 인터럽트라고 한다.

- 예외가 발생하면 하던 일을 중단하고 해당 예외를 처리한다. 그리고 다시 본래 작업으로 돌아와 실행을 재개한다.
- 마찬가지로 인터럽트 서비스 루틴을 이용하여 인터럽트에 대응한다.
- 다양한 예외 종류가 존재한다.

    - 폴트
        - 본래 작업으로 돌아왔을 때, 예외가 발생한 명령어부터 실행하는 경우다.
        
        - 예외가 발생한 명령어를 반드시 실행해야 하는 경우 사용된다.
    - 트랩
        - 본래 작업으로 돌아왔을 때, 예외가 발생한 명령어 다음부터 실행하는 경우다.
        - 디버깅 등 예시가 존재한다.
    - 중단
        - CPU가 실행 중인 프로그램을 강제로 중단하는 경우다.
    - 소프트웨어 인터럽트
        - 시스템 콜이 발생했을 때, 나타나는 예외다.

## CPU 성능 향상을 위한 설계

### CPU 클럭 속도

- CPU의 작동 단위가 클럭이기 때문에, 클럭 속도가 높아질수록 CPU의 작동 속도가 빨라진다.
- 반면 발열이 심해진다.

### 멀티코어와 멀티스레드

- 코어
    - 전통적인 CPU 구성 수 (8코어 : CPU 세트 8개)
- 스레드
    - 실행 흐름의 단위를 나타내며, 하드웨어 스레드와 스프트웨어 스레드로 나뉜다.
    - 하드웨어 스레드의 경우 CPU에서 사용되는 스레드
    - 스프트웨어 스레드의 경우, 프로그래밍 언어 및 운영체제에서 사용되는 스레드
- 하드웨어 스레드
    - 하나의 코어가 동시에 처리하는 명령어 단위. 논리 프로세서라고 부르기도 한다.

    - 하나의 코어가 2개 이상의 명령어를 동시에 처리하는 경우 → 멀티스레드 프로세서
    - 여러 task를 겹쳐서 처리할 수 있는 병렬성을 가진다. 이는 여러 CPU가 동시에 task를 맡아 실행하는 것이다.
- 소프트웨어 스레드
    - 하나의 프로그램에서 독립적으로 실행되는 단위
    
    - 여러 task를 동시에 처리할 수 있는 동시성을 가진다. 그러나 이는 하나의 CPU가 여러 task를 번갈아가며 실행하는 것이다.

## 파이프라이닝을 통한 명령어 병렬 처리

- 명령어 병렬 처리 기법은 CPU를 쉬지 않고 작동시켜 성능을 높이는 기법이다. 파이프라이닝, 슈퍼스칼라 등 다양한 종류가 존재한다.

- 파이프라이닝은 겹치지 않는 단계를 동시에 실행하는 방식이다. 명령어의 경우 인출 → 해석 → 실행 → 저장 단계로 나뉘는데, 각 단계를 동시에 실행시켜 최대한 많은 명령어를 처리한다.
- 파이프라이닝은 한계가 존재한다.
    - 명령어 수행 시간이 길거나 불규칙적일 경우, 처리 효율이 감소한다. 한 번의 처리에 모든 명령어 단계가 완전히 수행되어야 하기 때문에, 수행 시간이 길어지기 때문이다.

    - 데이터 위험이 존재한다. 데이터의 의존성으로 명령어 동시 처리가 불가능한 경우를 의미한다. 예를 들어, 하나의 명령어가 결과값을 계산하는 동안, 그 결과값을 필요로 하는 다음 명령어가 대기해야 하는 상황이 있다.
    - 제어 위험이 존재한다. jump, branch와 같은 명령어가 사용되면 파이프라인에 넣을 다음 명령어를 미리 결정할 수 없어 문제가 발생한다. → 파이프라이닝 아키텍쳐에서 다음 명령어는 어느 시점에 결정되고 적재되는가?
    - 구조적 위험이 존재한다. 서로 다른 명령어가 동시에 ALU, 레지스터 등 같은 CPU 부품을 사용할 수 있다. 이를 자원 위험이라고도 부른다.
