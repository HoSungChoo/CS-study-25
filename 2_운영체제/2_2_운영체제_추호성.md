# 3. 동기화와 교착 상태

다음 그림을 확인하자

- 공유 자원 : 여러 프로세스 혹은 스레드가 공유하는 자원

- 임계 구역 : 공유 자원에 접근하는 코드 중 동시에 실행했을 때 문제가 발생할 수 있는 코드
- 경쟁 상태 : 임계 구역의 코드를 동시에 실행하여 문제가 발생하는 상황
- 동기화 : 경쟁 상태를 방지기 위한 조건

![CS 스터디-13](https://github.com/user-attachments/assets/20d172b3-dfeb-4cf5-b4a2-7faa47486f9d)
    
## 동기화 기법

동기화

- 동기화는 다음 조건을 만족해야 한다.

    - 실행 순서 제어 : 프로세스 및 스레드를 올바른 순서로 실행하기

    - 상호 배제 : 동시에 접근하면 안되는 자원에 하나의 프로세스 및 스레드만 접근하기
- 다양한 동기화 기법이 있다.

뮤텍스 락

- 락을 소유하고 있는 대상만 공유 자원을 사용할 수 있도록 하는 기법이다.

- 상호 배제 조건을 충족시켜주며, 1개의 공유 변수와 2개의 함수로 구현된다
    - lock.acquire : 락을 획득하고 임계 구역에 진입하는 함수

    - lock.release : 락을 해제하는 함수

세마포어

- 공유 자원을 한정된 대상이 사용할 수 있도록 제한하는 기법이다. 하나의 공유 자원에 여러 대상이 진입할 수 있다.

- 상호 배제 조건을 충족시켜주며, 1개의 공유 변수와 2개의 함수로 구현된다.

    - 변수 S : 사용 가능한 공유 자원의 개수를 나타낸다.
    
    - wait : 임계 구역 진입 전에 호출한다. S가 양수인 경우 -1 후 진입하고, 아닌 경우 대기한다.
    - signal : 임계 구역 탈출 후에 호출한다. S가 양수인 경우 다른 대상이 진입하고, 아닌 경우 대기한다.
- 뮤텍스 락을 포괄하는 개념이다(이진 세마포어가 뮤텍스 락과 같은 역할을 한다)

조건 변수

- 특정 조건 하에 대상을 실행, 중지시키며 대상의 실행 순서를 제어하는 기법이다.

- 선언된 조건 변수를 포함한 대상을 실행, 중지시키는 역할인거 같다.
- 실행 순서 제어 조건을 충족시켜주며, 2개의 함수로 구현된다.
    - wait : 호출한 대상의 상태를 대기 상태로 전환한다.

    - signal : 중지된 대상을 재개한다.

모니터

- 공유 자원과 이를 다루는 인터페이스로 구성된 동기화 도구다.

- 자원을 관리하는 하나의 시스템으로, 인터페이스와 큐를 이용하여 대상의 동시성 문제를 관리한다.(= 상호 배제)
- 조건 변수를 이용해 실행 의존성이 있는 대상을 올바른 순서로 실행하도록 돕는다(= 실행 순서 제어) (프로세스 실행 순서가 A → B 인데, B가 먼저 입력될 경우, B를 wait 시킨 뒤 A를 실행하고 signal 한다)
- 즉, 상호 배제 및 실행 순서 제어 조건을 충족시켜준다.

스레드 안전

- 멀티 스레드 환경에서 변수, 함수, 객체에 동시에 접근이 이루어져도 문제가 없음을 의미한다.(레이스 컨디션이 발생되지 않음)

- 자바의 synchronized는 모니터 기반의 동기화 기법을 사용한다.
- 자바의 vector는 스레드 안전인데 비해, ArrayList의 경우 그렇지 않다.

## 교착 상태

정의

- 일어나지 않을 사건을 기다리며 프로세스의 진행이 멈춰버리는 현상

- 프로세스 A는 X자원을 점유하며 Y자원을 기다리고 있고, 프로세스 B는 Y자원을 점유하며 X자원을 기다리고 있는 현상이다
- 4가지 발생 조건이 모두 충족될 경우 교착 상태가 발생한다.

발생 조건

- 상호 배제

    - 한 번에 하나의 프로세스만 해당 자원을 이용 가능한 상황

    - 즉, 한 프로세스가 사용하는 자원을 다른 프로세스는 사용할 수 없는 상황
- 점유와 대기
    - 프로세스가 어떤 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상황
- 비선점
    - 자원을 선점한 프로세스의 작업이 끝나야 해당 자원을 반납하는 상황
- 원형 대기
    - 프로세스와 프로세스가 요청한 자원의 사이클을 이루는 상황

    - A 프로세스는 X를 점유하며 Y를 기다림. B 프로세스는 Y를 점유하며 Z를 기다림. C 프로세스는 Z를 점유하며 X를 기다림 → 사이클 발생

해결 방법

- 교착 상태 예방

    - 교착 상태 발생 조건 중 하나 이상을 충족하지 못하게 한다.

    - 프로세스에 번갈아가며 자원을 몰아주는 방식, 자원에 번호를 매기고 오름차순으로 할당하는 방식 등 존재한다.
- 교착 상태 회피
    - 교착 상태가 발생하지 않을 정도로만 조심하면서 자원을 할당하는 방법

    - 자원의 가용 수 보다 프로세스 수가 적을 경우 문제가 생기지 않는다 ?
    - 은행원 알고리즘을 통해 교착 상태를 회피할 수 있다.
- 교착 상태 검출 및 회복
    - 교착 상태가 발생한 대상을 검출하고 해결하는 방식이다.

    - 프로세스를 자원 선점을 통해 회복시키거나, 문제가 되는 프로세스를 강제 종료시켜 사이클을 제거한다.
    - 결국 사이클이 발생하기 때문에 나타나는 문제이므로, 사이클을 끊는 방식을 이용한다.

은행원 알고리즘

- 은행원 알고리즘이란 '최소한 고객 한 명에게 대출해줄 금액은 항상 은행이 보유하고 있어야 한다'라는 개념에서 나온다.

- 교착 상태에 빠질 가능성이 있는지 판단하기 위해 상태를 안전 상태와 불안전 상태로 나누고, 안전 상태를 유지할 수 있는 요구만을 수락하고, 불안전 상태를 초래할 수 있는 사용자의 요구는 만족될 수 있을 때까지 계속해서 거절하는 방법이다.
- 자세한건 패스 ~

# 4. CPU 스케줄링

## CPU 스케줄링

정의

- 다양한 프로세스와 스레드에 효율적으로 CPU 자원을 배분하는 알고리즘

- CPU 스케줄러 : CPU 스케줄링 알고리즘을 결정하고 수행하는 운영체제의 일부분
- 실행의 문맥이 있다면 모두 스케줄링 대상(프로세스, 스레드 포함)

우선순위

- 운영체제는 프로세스별로 우선순위를 판단하여 PCB에 명시하며, 높은 우선순위를 가진 프로세스에 CPU 자원을 더 빨리, 더 많이 할당한다.

- CPU 활용률 : 전체 CPU 가동 시간 중, 작업을 처리하는 시간 비율
- 프로세스는 CPU와 입출력 장치를 오가며 서비스를 실행한다. 해당 장치를 이용하는 작업을 각각 CPU 버스트, 입출력 버스트라고 한다.
- CPU 버스트가 많은 프로세스를 CPU 집중 프로세스라고 하며, 입출력 버스트가 많은 프로세스를 입출력 집중 프로세스라고 한다.
- 각 프로세스 유형의 상태 별 체류 시간이 다르기 때문에 CPU 자원을 다르게 할당해야 한다.
- CPU → 입출력 장치 순서로 작동하기 때문에 같은 요청이 들어올 경우, 입출력 중점 프로세스가 먼저 실행된다.

스케줄링 큐

- 운영체제가 프로세스의 상태를 관리하기 위해 사용하는 공간이다.

- 대표적으로 2개의 큐가 존재한다.
    - 준비 큐
        - CPU를 할당받기 위해 대기하는 공간
    - 대기 큐
        - 입출력 장치 수행 중, 해당 작업이 완료될 때 까지 대기하는 공간

        - 같은 입출력 장치를 요구한 프로세스는 같은 대기큐에서 대기한다.
        - 대기 큐에서 입출력 장치로부터 인터럽트를 받은 경우, 준비 큐로 이동하게 된다.
- 스케줄링 큐는 다음과 같이 작동한다.

선점형 스케줄링과 비선점형 스케줄링

- 실행 도중 스케줄링이 수행되는 시점

    - 실행 상태에서 입출력 작업을 위해 대기 상태로 전환되는 시점

    - 실행 상태에서 타이머 인터럽트가 발생해 준비 상태로 전환되는 시점
- 선점형 스케줄링
    - 프로세스로부터 CPU 자원을 강제로 빼앗다 다른 프로세스에 할당하는 스케줄링

    - 입출력 작업, 타이머 인터럽트에 의해 CPU 자원이 이동한다
    - CPU 자원을 모든 프로세스에 합리적으로 할당할 수 있지만, 문맥 교환 과정에서 오버헤드가 발생할 수 있다.
- 비선점형 스케줄링
    - 프로세스가 종료 혹은 대기 상태가 될 때까지 CPU 자원을 할당하는 스케줄링

    - 입출력 작업을 통해서만 CPU 자원이 이동한다.
    - 문맥 교환이 줄어들어 오버헤드가 적지만, CPU가 급하게 필요한 프로세스에게 CPU 자원을 당장 제공할 수 없다는 단점이 있다.

## CPU 스케줄링 알고리즘

CPU 스케줄링 종류

- 선입 선처리 스케줄링

    - 준비 큐에 삽입된 순서대로 CPU를 할당하는 방식

    - 비선점형 스케줄링
    - 오랜 시간이 걸리는 프로세스가 먼저 입력되면 호위 효과가 발생할 수 있다.
- 최단 작업 우선 스케줄링
    - CPU 이용 시간이 가장 짧은 프로세스를 우선적으로 실행하는 방식

    - 비선점형 스케줄링
    - 짧은 프로세스가 지속적으로 입력될 경우, 긴 프로세스에 CPU가 할당받지 못한다는 단점이 있다. 이를 기아 문제라고 하며, aging으로 해결할 수 있다.
- 라운드 로빈 스케줄링
    - 선입 선처리 스케줄링 방식 + 타임 슬라이스 방식으로, 단위 시간만큼 CPU를 이용한다.

    - 선점형 스케줄링
    - 단위 시간 내에 작업을 완료하지 못할 경우, 대기 큐의 맨 뒤로 할당된다
    - 단위 시간이 작으면 문맥 교환에 따른 오버헤드가 크게 발생하며, 단위 시간이 크면 선입 선처리 스케줄링과 같은 효과를 가지게 된다
- 최소 잔여 시간 우선 스케줄링
    - 최단 작업 우선 스케줄링 + 타임 슬라이스 방식으로, 단위 시간만큼 CPU를 이용하되, 작업 시간이 가장 작은 프로세스를 다음으로 선택한다.

    - 선점형 스케줄링
    - 마찬가지로 기아 상태가 발생할 수 있다.
- 우선순위 스케줄링
    - 프로세스에 우선순위를 부여하고 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식

    - 기아 문제가 발생할 수 있으며, 이를 aging으로 해결할 수 있다.
- 다단계 큐 스케줄링
    - 우선 순위가 다른 여러 개의 큐를 만든 뒤, 가장 높은 우선순위를 가진 큐에 존재하는 프로세스부터 처리하는 방식

    - 프로세스는 큐 간 이동이 불가능하기 때문에, 낮은 우선순위 큐에 존재하는 프로세스가 기아 문제를 겪을 수 있다. → 이를 해결하는게 다단계 피드백 큐 스케줄링
- 다단계 피드백 큐 스케줄링
    - 다단계 큐 스케줄링과 마찬가지로 여러 개의 큐를 대기한다. 해당 큐에서 프로세스가 타임 슬라이스 동안 실행을 완료하지 못한다면, 다음 우선순위 큐에 입력된다. 이를 다시 반복한다.

    - 해당 방식은 CPU를 오랫동안 사용해야 하는 ‘CPU 집중 프로세스’의 우선순위는 낮아지고, ‘입출력 집중 프로세스’의 우선순위가 높아지는 특징을 가지고 있다.
    - 기아 현상이 발생할 수 있으며, aging을 이용하여 해결할 수 있다.

## 리눅스 CPU 스케줄링

- 타임 슬라이스는 프로세스의 가중치에 따라 다르게 할당받을 수 있다.

- 리눅스는 다섯 개의 스케줄링 정책을 이용한다(FIFO, RR, NORMAL, BATCH, IDLE)
- FIFO, RR은 real-time 스케줄러에 의해 이뤼지는 스케줄링이다.
- NORMAL은 CFS라는 스케줄러에 의해 이루어지는데, 완전히 공평한 CPU 시간 배분을 의미한다.
- CFS는 vruntime에 의해 우선 순위가 결정되는데, 작을수록 먼저 스케줄링된다.
- vruntime은 CPU를 할당받아 실행된 시간에 비례하며 프로세스의 가중치(=우선순위)에 반비례한다.
- 따라서, 가중치가 높아질수록 vruntime은 감소하며, 점점 스케줄링 우선권을 가지게 된다.
- CFS의 타임 슬라이스 역시 프로세스의 가중치와 비례하며, 가중치가 높아질수록 높은 타임 슬라이스를 가지게 된다. → CPU를 더 오래 할당받을 수 있다.
- CFS는 RB tree를 통해 vruntime을 관리하며, 최솟값과 최댓값을 효율적으로 찾는다.

---
## 질문

- 뮤텍스 락은 어디서 관리되는가?

- 세마포어에서 대기 스레드 선택은 어떤 기준인가? 큐같은게 있나..?
- 프로세스끼리 자원을 공유하는 상황에 대한 예시가 있나
- A, B, C가 1, 2, 3 자원을 점유하는 경우 이는 상호 배제에서 벗어난 케이스 아닌가?
- 프로세스 간 자원 할당의 예시가 있나 ?
