# 1. 운영체제의 큰 그림

- 운영체제는 컴퓨터 하드웨어와 사용자 사이를 중재하고, 프로그램들이 효율적이고 안전하게 동작할 수 있도록 도와주는 소프트웨어다.

- 커널은 운영체제의 핵심 부분으로, 하드웨어를 제어하고 자원을 관리하며, 메모리의 보호된 영역에 존재한다.(운영체제에서 커널 외 영역도 존재하며, 디바이스 드라이버, 라이브러리, 유틸리티 등이 존재한다)
- 운영체제는 자원 할당 및 관리 기능, 프로세스 및 스레드 관리 기능을 가진다.
- 운영체제는 다음과 같은 개념 흐름을 가진다.

## 운영체제의 역할

### CPU 관리 : CPU 스케줄링

- 프로그램을 실행하기 위해선 CPU를 할당받아야 한다.

- 운영체제는 CPU 스케줄링을 통해 CPU 자원을 여러 프로그램에 적절하게 할당한다.
- CPU 스케줄링은 다양한 방법이 존재한다.

### 메모리 관리 : 가상 메모리

- 운영체제는 프로그램을 메모리에 적재 및 삭제하는 기능을 담당한다.

- 가상 메모리 기술을 통해, 실제 물리 메모리보다 더 큰 메모리를 이용할 수 있도록 한다.

### 파일/디렉터리 관리 : 파일 시스템

- 운영체제는 파일 시스템 개념을 통해 보조기억장치에 데이터를 효율적으로 관리한다.

- 덕분에 사용자는 효율적으로 데이터에 접근 및 관리할 수 있다.

### 프로세스 및 스레드 관리

- 메모리에 올려져있는 실행 중인 프로그램 → 프로세스

- 프로세스를 이루는 실행 단위 → 스레드
- 운영체제는 동시다발적으로 실행되는 프로세스와 스레드가 올바르게 처리되도록 실행 순서를 제어하고, 프로스세와 스레드가 요구하는 자원을 적절하게 배분한다.

## 시스템 콜과 이중 모드

메모리 영역 구성

- 메모리는 커널 영역 + 사용자 영역으로 구성되어 있다.

- 커널 영역은 운영체제 프로그램을 담는 영역이다.
- 사용자 영역은 사용자 응용 프로그램을 담는 영역이다.
- 운영체제의 기능을 사용하기 위해선 반드신 커널 영역에 적재된 운영체제 코드를 실행해야 한다. 즉, 사용자 영역에서 컴퓨팅 자원(프로세스 생성, 파일 쓰기 등)을 사용하기 위해선 커널 영역을 반드시 거쳐야 한다.

시스템 콜

- 사용자 영역에 존재하는 응용 프로그램은 시스템 콜을 이용하여 운영체제 코드를 실행한다.

- 시스템 콜은 인터페이스 형식이며, 호출 가능한 함수의 형태를 가진다.
- 즉, 응용 프로그램이 운영체제의 특정 기능을 이용하고자 할 때, 시스템 콜을 호출하는 방식을 이용한다.
- 시스템 콜은 SW 인터럽트의 일종이다.
- 시스템 콜은 목적에 따라 `프로세스 관리`, `파일 관리`, `디렉터리 관리`, `파일 시스템 관리` 등 으로 나뉜다. 예시로 `fork()`, `open()`, `chdir()` 등이 존재한다.

시스템 콜의 발생 흐름

- SW 인터럽트 발생(시스템 콜 호출) → 기존 CPU 작업 백업 → 기존 CPU 사용자 모드에서 커널 모드 전환 → 운영체제 코드 실행 → 커널 모드에서 사용자 모드로 재전환 흐름이 실행된다.

- CPU는 명령어를 실행하는 과정에서 사용자 모드, 커널 모드로 구분하여 실행하며, 이를 이중 모드라고 한다.
- 사용자 모드는 운영체제 서비스를 제공받을 수 없는 실행 모드다.(자원 접근이 불가능하다)
- 커널 모드는 운영체제 서비스를 제공받을 수 있는 실행 모드다. 즉, 운영체제가 관리하는 컴퓨팅 자원을 사용하기 위해선 커널 모드가 되어야 한다.

![image.png](attachment:c8034ce3-c38a-4814-a214-2ede0136bd6b:image.png)

# 2. 프로세스와 스레드

- 메모리는 커널 영역 + 사용자 영역으로 구성되어 있다.

- 커널 영역은 운영체제 프로그램이 입력되어 있으며, PCB 데이터를 테이블 형태로 관리한다.
- 사용자 영역은 주로 여러 개의 프로세스로 구성되어 있으며, 하나의 프로세스는 스택 + 힙 + 데이터 + 코드 영역으로 구성되어 있다.
- 코드 영역
    - 실행 가능한 명령어가 저장된 공간

    - CPU가 읽고 실행할 명령어가 담겨있기 때문에 read-only 속성을 가진다.

- 데이터 영역
    - 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간이다.

    - 주로 정적 변수, 전역 변수를 가진다9변수의 변경 가능성이 존재한다)
    - 프로세스와 같은 생명주기를 가진다(프로세스가 실행될 때 데이터를 가지며, 종료될 때 소멸된다)
    - BSS 영역이라는 별도의 영역을 가지는데, 초기화되지 않은 변수를 저장하는 공간이다.
- 힙 영역
    - 프로그램 실행 중 자유롭게 할당하여 사용 가능한 메모리 공간이다.

    - 객체, 배열, 참조형 변수 값 등 다양한 데이터가 담긴다.
    - 메모리를 해제하지 않으면 누수가 발생할 수 있다. GC를 이용하여 이를 해결할 수 있다.
- 스택 영역
    - 짧은 생명주기를 가지는 값들이 저장되는 공간이다.

    - 매개변수, 지역변수, 함수 복귀 주소 등이 저장된다.
    - 또한, 스택 트레이스 형태의 함수 호출 정보가 저장된다. 이는 오류 발생 지점을 알려주는 중요한 정보다.

### 프로세스 제어 블록

- 프로세스 제어 블록(PCB)은 프로세스를 식별할 수 있는 정보와 현재 상태를 나타내는 메타 데이터다.

- PCB는 프로세스 ID, 실행 과정에서 사용한 레지스터 값, 프로세스 상태, CPU 스케줄링 정보 등 다양한 정보를 보유하고 있다.
- PCB는 구조체 형태를 가진다. 또한, 커널 영역에서 테이블 형태(=프로세스 테이블)로 관리되며, 프로세스 생명 주기에 맞춰 생성 및 폐기된다. (프로세스 테이블은 PCB 값을 참조하며, 구체적인 PCB 데이터는 별도로 관리된다)
- 프로세스의 비정상 종료로 인해 프로세스의 자원이 해제됐는데도, 프로세스 테이블에 PCB가 남아있는 경우 → 좀비 프로세스

### PCB와 문맥 교환

- 운영체제는 소수의 CPU 자원으로 여러 프로세스를 번갈아 작동시킨다. 이 과정에서 특정 프로세스 작동 중간에 작업을 멈추고 다른 프로세스에 CPU를 할당할 수 있다.

- 타이머 인터럽트는 프로세스의 CPU 점유 시간을 관리한다. CPU 할당 후 일정 시간 뒤, 타이머 인터럽트가 발생하면, CPU 자원은 다른 프로세스로 넘어간다.
- 각종 레지스터 값, 메모리 정보, 파일 정보 등 프로세스 작동 중 발생한 데이터를 문맥이라고 한다. 프로세스가 교체되는 과정에서 문맥 교환이 일어나는데, 문맥 교환이란, 기존 프로세스의 문맥을 백업한 뒤, 변경되는 프로세스의 문맥을 복구하고 실행하는 과정을 의미한다.
- 문맥 교환이 자주 발생할수록 많은 프로세스를 효율적으로 실행할 수 있지만, 문맥 교환 비용 및 캐시 미스가 발생하여 속도가 저하될 수 있다.

### 프로세스의 상태

- 프로세스는 여러 상태를 거친다. 대표적으로 생성, 준비, 실행, 대기, 종료 상태를 가진다.

- 생성
    - 프로세스 생성 중인 상태로, 메모리에 적재되어 PCB를 할당 받는다.

    - 사용자 영역에 프로세스가 놓일 수 있는 메모리 공간을 받음 + 커널 영역의 프로세스 테이블에 PCB 추가
- 준비
    - CPU를 할당 받을 수 있는 상태로, 준비 큐에 적재되어 있다. 실행 상태로 전환되는 것을 디스패치라고 한다.

    - 해당 PCB 데이터가 대기 큐에 입력
- 실행
    - CPU를 할당 받아 실행되고 있는 상태다. 타이머 인터럽트가 발생하면 실행을 멈추고 준비 상태로 변한다.

    - 입출력 요청 등 CPU 실행이 불가능한 경우 대기 상태로 전환된다. 이 때, 프로세시는 입출력 대기 큐와 같은 큐에 적재된다.
    - 대기 큐에서 PCB 데이터가 poll되며 해당 프로세스에 CPU를 할당 받음 → CPU는 사용자 영역에 존재하는 해당 프로세스 영역을 읽으며 실행
- 대기
    - CPU 실행이 불가능할 경우 전환되는 상태다.

    - IO 대기 큐 등 목적에 맞는 큐에 PCB 데이터가 적재. 다시 실행될 경우 해당 데이터가 poll
- 종료
    - 프로세스가 작업을 마치고 종료되는 상태다.

    - 프로세스가 종료되면 PCB와 프로세스가 사용한 메모리를 정리한다.
    - 커널 영역의 프로세스 테이블에서 해당 데이터 삭제 + 사용자 영역에서 해당 영역 삭제
        
        ![Screenshot 2025-07-06 at 1.21.12 AM.png](attachment:5d92e1d4-0863-40d2-9627-f52d4ee6e111:Screenshot_2025-07-06_at_1.21.12_AM.png)
        

### 동기와 비동기(sync vs async)

개요
- “요청한 작업의 완료 시점에 얼마나 관심을 가지는가” 에서 차이를 가진다.

- 기존 동기, 비동기를 작업이 순차적으로 일어나는가, 순서에 상관 없이 일어나는가로 인식하고 있었다. 그러나 이는 “작업 흐름이 완료 시점에 얽매이는가”의 관점으로 이해할 수 있다.

- 너의 작업이 궁금해… 아니 완료 하던 말던 전혀 관심 없어..

동기
- 호출한 작업의 시점과 결과에 관심을 가지며, 해당 작업이 끝날 때 까지 기다리고, 결과에 맞춰 다음 동작을 수행한다.

비동기
- 작업 완료를 기다리지 않고 흐름을 이어가며, 결과는 나중에 콜백/이벤트를 통해 처리된다. 결과가 필요하면 나중에 받아서 처리하고, 필요 없을 수도 있다.

### 블로킹과 논블로킹(blocking vs non-blocking)

개요
- “호출자를 기다릴 것이냐, 기다리지 않고 나의 일을 할 것이냐”에서 차이를 가진다.

- 다른 주체가 작업을 할 때, 자신에게 제어권이 존재하는가 ?

- 너만 바라보며 기다릴꺼야.. 아니 내 할 일 할꺼야..

블로킹
- 호출자를 기다린다

- 호출자를 기다리는 동안 아무 일도 하지 못한다.

논블로킹
- 제어권을 즉시 회수하며 나의 일을 계속 한다.
        
        ![Screenshot 2025-07-06 at 1.27.45 PM.png](attachment:319464cc-34f2-48b2-8d15-9969f1ed659e:Screenshot_2025-07-06_at_1.27.45_PM.png)
        

너무 어렵다…..

|  | 동기(너의 작업이 궁금해..) | 비동기(사실 안궁금해^^) |
| --- | --- | --- |
| 블로킹 (너만 보며 기다릴꺼야..) | 너의 작업이 너무 궁금하며, 너의 작업이 끝날 때 까지 기다릴꺼야 (자바의 입력 대기 등) | 너의 작업이 궁금하진 않은데, 널 기다리긴 할꺼야 (거의 사용되지 않음) |
| 논블로킹(내 할일 할꺼야^^) | 너가 어떤 작업을 하는지, 언제 끝나는지 궁금하긴 한데, 너만 보며 기다리진 않을꺼고, 가끔 확인하러 올께 (로딩 화면 등) | 너의 작업이 별로 궁금하지 않으니, 완료되면 알려줘. 해당 결과는 처리하던 말던 알아서 할께 (JS 비동기 fetch 등) |

참고 

- https://www.youtube.com/watch?v=oEIoqGd-Sns
- https://haneepark.github.io/2021/07/18/blocking-nonblocking-sync-async/
- [https://velog.io/@nittre/블로킹-Vs.-논블로킹-동기-Vs.-비동기](https://velog.io/@nittre/%EB%B8%94%EB%A1%9C%ED%82%B9-Vs.-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%8F%99%EA%B8%B0-Vs.-%EB%B9%84%EB%8F%99%EA%B8%B0)

## 멀티 프로세스와 멀티 스레드

### 멀티 프로세스

- 동시에 여러 프로세스가 실행되는 형태

- 프로세스 간 자원을 공유하지 않으며, 독립적으로 실행된다.
- 즉, 프로세스 간 영향을 주지 않는다.

### 멀티 스레드

- 프로세스의 실행 흐름 단위를 스레드라고 하며, 하나의 프로세스에 여러 스레드가 존재할 수 있다. 이를 동시에 실행하는 환경을 멀티 스레드라고 한다.

- 스레드는 스레드 ID, 프로그램 카운터, 레지스터 값, 스택 등을 독립적으로 보유하고 있으며, 프로세스 내 힙, 데이터, 코드 영역을 공유한다.
- 스레드는 프로세스에 비해 문맥 교환 비용이 적고, 자원을 공유하기 때문에 가볍고 빠르다는 장점이 있다. 그러나 스레드 간 영향을 줄 수 있다는 단점이 있다.
- 스레드는 또 다른 스레드를 생성할 수 있다(스레드가 일종의 작업 공간이기 때문에 그럴 수 있다) 스레드 join 메서드는 스레드가 생성한 스레드가 종료될 때 까지 기다리는 기능을 가진다. 이는 스레드 간 동기 기능을 제공한다.

## 프로세스 간 통신

- 스레드와 다르게 프로세스는 직접 통신할 수 없다.

- 프로세스는 다양한 방식으로 통신한다.

### 공유 메모리

- 여러 프로세스들이 접근할 수 있는 메모리 영역을 제공하는 방식

- 통신 속도가 빠르다는 장점이 있지만, 동시 접근에 따른 race condition이 발생할 수 있다. 이에 따라 데이터 일관성이 훼손될 수 있다는 단점이 있다.

### 메세지 전달

- 프로세스 간 주고받을 데이터가 커널을 거쳐 송수신되는 방식이다. 시스템 콜을 이용한다.

- 커널이 송신을 관리하기 때문에, 동기화 문제를 해결할 수 있다는 장점이 있지만, 통신 속도가 느리다는 단점이 있다.
- 대표적으로 파이프, 시그널, 소켓, 원격 프로시저 등이 있다.
- 파이프
    - 단방향 프로세스 간의 통신 도구. 양방향을 원할 경우 2개의 파이프를 이용한다.

    - 커널 내 버퍼(큐 형태)에 적재되고 전송하는 방식이다.
    - 익명 파이프는 부모, 자식 프로세스가 소통하는 방식이다. 지명 파이프는 양방향 통신을 지원하며 임의의 프로세스 간에도 사용될 수 있다.
- 시그널
    - 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기적 신호
    
    - `kill(1234, SIGTERM)` 다음과 같이, 특정 프로세스에 특정 시그널을 보낸다