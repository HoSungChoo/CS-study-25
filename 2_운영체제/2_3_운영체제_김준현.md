# 5. 가상메모리

가상메모리 : 운영체제의 메모리 관리 기법

CPU는 어떻게 메모리에 적재된 프로세스의 주소를 인식하고 관리할까?

→ 논리주소, 가상 메모리, 페이징의 개념에 대해 알아야한다.

## 물리 주소와 논리주소

**논리주소 (logical address)** : 프로세스마다 부여되는 0번지부터 시작하는 주소 체계

<img width="1336" height="536" alt="image" src="https://github.com/user-attachments/assets/005019e5-f26c-452e-9282-0c8cdbc63137" />

메모리 관리 장치 (MMU : Memory Management Unit)

- CPU가 이해하는 논리주소를 메모리가 이해하는 물리 주소로 변환하는 역할

- CPU와 메모리 사이에 위치 

- MMU를 기준으로 물리 주소와 논리 주소가 변환된다!

## 스와핑과 연속 메모리 할당

### 스와핑

메모리에 적재된 프로세스들 중에는 현재 실행되고 있지 않은 프로세스가 있을 수 있다.

입출력 작업을 요구하며 대기 상태가 되었거나, 오랫동안 사용되지 않은 프로세스들을

임시로 **스왑 영역 (swap space)** 라는 보조기억장치의 일부인 영역으로 쫗아낸다.

- **스와핑 (swapping)** : 프로세스를 쫒아낸 자리에 생긴 메모리 상의 빈 공간에 다른 프로세스를 적재하여 실행하는 메모리 관리 방식

- **스왑 아웃 (swap-out)** : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것

- **스왑 인 (swap-in)** : 스왑 영역에 있는 프로세스가 다시 메모리로 옮겨오는 것

이처럼 운영체제는 **스와핑** 이라는 기본적인 메모리 관리 기법을 통해 프로세스들을 메모리 내 빈 공간을 적재한다.

### 연속 메모리 할당과 외부 단편화

- **연속 메모리 할당** : 프로세스에 연속적인 메모리 공간을 할당하는 방식

- **외부 단편화**라는 문제가 발생해서 연속 메모리 할당은 메모리를 효율적으로 사용하는 방법은 아니다.

프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스의 실행과 종료가 반복되며 메모리 사이 사이에 빈 공간이 생긴다. 

빈 공간보다 큰 프로세스는 할당되기 어렵고, 이것은 메모리 낭비이다. 이것이 외부 단편화(external fragmentation)이다.

## 페이징을 통한 가상 메모리 관리

**스와핑과 연속 메모리 할당의 2가지 문제**

1. 외부 단편화 (메모리 낭비)

2. 물리 메모리보다 큰 프로세스를 실행할 수 없다는 점

이러한 문제를 해결하는 운영체제의 메모리 관리 기술 → **가상 메모리**

- **가상 메모리 (virtual memory)** : 실행하고자 하는 프로그램의 일부만 메모리에 적재해, 실제 메모리보다 더 큰 프로세스를 실행할 수 있도록 만드는 메모리 관리 기법

### 가상 메모리 관리 기법

1. 페이징

- 프로세스의 논리 주소 공간을 페이지(page)라는 일정한 단위로 나누고,

  물리 주소 공간을 페이지와 동일한 크기의 프레임(frame)이라는 일정한 단위로 나눈 뒤, **페이지를 프레임에 할당하는 가상 메모리 관리 기법**

<img width="800" height="500" alt="image" src="https://github.com/user-attachments/assets/bf9dccc9-b2ae-4887-8024-b0aa689eef56" />


- 페이지라는 일정한 크기로 잘린 프로세스들을 메모리에 불연속적으로 할당할 수 있다면, 

  연속 메모리 할당처럼 프로세스 바깥에 빈 공간이 생길 수 없어 외부 단편화가 발생하지 않는다.

**페이징에서의 스와핑**

<img width="2136" height="896" alt="image" src="https://github.com/user-attachments/assets/284706bd-8b61-4d3a-b1db-694b7edbfef0" />

- 페이지 단위의 스왑 인(페이지 인), 스왑 아웃(페이지 아웃)

- 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃

- 실행에 필요한 페이지들은 메모리로 스왑 인

<img width="1466" height="602" alt="image" src="https://github.com/user-attachments/assets/2f8ba272-26b6-4e6f-b67d-c0df4a9d7628" />

- 프로세스를 실행하기 위해 모든 페이지가 적재될 필요 없다.

- 즉, 물리 메모리보다 큰 프로세스도 실행될 수 있다. 
   
2. 세그멘테이션

- 프로세스를 일정한 크기의 페이지 단위가 아닌 가변적인 크기의 세그먼트(segment) 단위로 분할하는 방식

### 페이지 테이블

프로세스를 일정 크기로 자르고, 이를 메모리에 불연속적으로 할당할 수 있다면 어떨까?

**발생하는 문제** 

- 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 일일이 알기 어렵다.

- 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없다.

- CPU 입장에서 '다음에 실행할 명령어 위치'를 찾기가 어렵다.

위의 문제들을 해결하기 위해 프로세스의 페이지와 실제로 적재된 프레임을 짝지어주는 정보인 **페이지 테이블(page table)** 을 활용한다.

- (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도, (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 하는 방법

- 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표

<img width="1258" height="696" alt="image" src="https://github.com/user-attachments/assets/7cc62839-afdc-4cf1-b0c1-be7dc11888ee" />




### 연속 메모리 할당과 외부 단편화

## 페이징을 통한 가상 메모리 관리

### 페이징 

### 페이지 테이블 

### 페이징 주소 체계

## 페이지 교체 알고리즘


# 6. 파일 시스템

- 보조기억장치의 정보를 파일 및 디렉터리(폴더)의 형태로 저장하고 관리할 수 있도록 하는 운영체제 내부 프로그램.

## 파일과 디렉터리

### 파일

### 디렉터리

### 파일 할당

## 파일 시스템

### 아이노드 기반 파일 시스템

### 마운트


# Reference

https://velog.io/@alsgur/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84-%EB%AC%BC%EB%A6%AC-%EC%A3%BC%EC%86%8C%EC%99%80-%EB%85%BC%EB%A6%AC-%EC%A3%BC%EC%86%8C

