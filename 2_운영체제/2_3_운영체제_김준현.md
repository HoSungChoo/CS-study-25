# 5. 가상메모리

가상메모리 : 운영체제의 메모리 관리 기법

CPU는 어떻게 메모리에 적재된 프로세스의 주소를 인식하고 관리할까?

→ 논리주소, 가상 메모리, 페이징의 개념에 대해 알아야한다.

## 물리 주소와 논리주소

**논리주소 (logical address)** : 프로세스마다 부여되는 0번지부터 시작하는 주소 체계

<img width="1336" height="536" alt="image" src="https://github.com/user-attachments/assets/005019e5-f26c-452e-9282-0c8cdbc63137" />

메모리 관리 장치 (MMU : Memory Management Unit)

- CPU가 이해하는 논리주소를 메모리가 이해하는 물리 주소로 변환하는 역할

- CPU와 메모리 사이에 위치 

- MMU를 기준으로 물리 주소와 논리 주소가 변환된다!

## 스와핑과 연속 메모리 할당

### 스와핑

메모리에 적재된 프로세스들 중에는 현재 실행되고 있지 않은 프로세스가 있을 수 있다.

입출력 작업을 요구하며 대기 상태가 되었거나, 오랫동안 사용되지 않은 프로세스들을

임시로 **스왑 영역 (swap space)** 라는 보조기억장치의 일부인 영역으로 쫗아낸다.

- **스와핑 (swapping)** : 프로세스를 쫒아낸 자리에 생긴 메모리 상의 빈 공간에 다른 프로세스를 적재하여 실행하는 메모리 관리 방식

- **스왑 아웃 (swap-out)** : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것

- **스왑 인 (swap-in)** : 스왑 영역에 있는 프로세스가 다시 메모리로 옮겨오는 것

이처럼 운영체제는 **스와핑** 이라는 기본적인 메모리 관리 기법을 통해 프로세스들을 메모리 내 빈 공간을 적재한다.

### 연속 메모리 할당과 외부 단편화

- **연속 메모리 할당** : 프로세스에 연속적인 메모리 공간을 할당하는 방식

- **외부 단편화**라는 문제가 발생해서 연속 메모리 할당은 메모리를 효율적으로 사용하는 방법은 아니다.

프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스의 실행과 종료가 반복되며 메모리 사이 사이에 빈 공간이 생긴다. 

빈 공간보다 큰 프로세스는 할당되기 어렵고, 이것은 메모리 낭비이다. 이것이 외부 단편화(external fragmentation)이다.

## 페이징을 통한 가상 메모리 관리

**스와핑과 연속 메모리 할당의 2가지 문제**

1. 외부 단편화 (메모리 낭비)

2. 물리 메모리보다 큰 프로세스를 실행할 수 없다는 점

이러한 문제를 해결하는 운영체제의 메모리 관리 기술 → **가상 메모리**

- **가상 메모리 (virtual memory)** : 실행하고자 하는 프로그램의 일부만 메모리에 적재해, 실제 메모리보다 더 큰 프로세스를 실행할 수 있도록 만드는 메모리 관리 기법

### 가상 메모리 관리 기법

1. 페이징

- 프로세스의 논리 주소 공간을 페이지(page)라는 일정한 단위로 나누고,

  물리 주소 공간을 페이지와 동일한 크기의 프레임(frame)이라는 일정한 단위로 나눈 뒤, **페이지를 프레임에 할당하는 가상 메모리 관리 기법**

<img width="800" height="500" alt="image" src="https://github.com/user-attachments/assets/bf9dccc9-b2ae-4887-8024-b0aa689eef56" />


- 페이지라는 일정한 크기로 잘린 프로세스들을 메모리에 불연속적으로 할당할 수 있다면, 

  연속 메모리 할당처럼 프로세스 바깥에 빈 공간이 생길 수 없어 외부 단편화가 발생하지 않는다.

**페이징에서의 스와핑**

<img width="2136" height="896" alt="image" src="https://github.com/user-attachments/assets/284706bd-8b61-4d3a-b1db-694b7edbfef0" />

- 페이지 단위의 스왑 인(페이지 인), 스왑 아웃(페이지 아웃)

- 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃

- 실행에 필요한 페이지들은 메모리로 스왑 인

<img width="1466" height="602" alt="image" src="https://github.com/user-attachments/assets/2f8ba272-26b6-4e6f-b67d-c0df4a9d7628" />

- 프로세스를 실행하기 위해 모든 페이지가 적재될 필요 없다.

- 즉, 물리 메모리보다 큰 프로세스도 실행될 수 있다. 
   
2. 세그멘테이션

- 프로세스를 일정한 크기의 페이지 단위가 아닌 가변적인 크기의 세그먼트(segment) 단위로 분할하는 방식

### 페이지 테이블

프로세스를 일정 크기로 자르고, 이를 메모리에 불연속적으로 할당할 수 있다면 어떨까?

**발생하는 문제** 

- 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 일일이 알기 어렵다.

- 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없다.

- CPU 입장에서 '다음에 실행할 명령어 위치'를 찾기가 어렵다.

위의 문제들을 해결하기 위해 프로세스의 페이지와 실제로 적재된 프레임을 짝지어주는 정보인 **페이지 테이블(page table)** 을 활용한다.

- (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도, (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 하는 방법

- 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표

<img width="1258" height="696" alt="image" src="https://github.com/user-attachments/assets/7cc62839-afdc-4cf1-b0c1-be7dc11888ee" />

- 프로세스마다 각자의 페이지 테이블 정보를 갖고 있으므로, CPU가 서로 다른 프로세스를 실행할 떄는 각 프로세스의 페이지 테이블을 참조하여 메모리에 접근한다.

### 페이지 테이블 엔트리 (Page Table Entry)

- 페이지 테이블의 각각의 행 : 페이지 테이블 엔트리 (PTE)

  - 페이지 번호, 프레임 번호

  - 유효 비트 (현재 해당 페이지에 접근 가능한지 여부 0/1)
 
    <img width="1190" height="618" alt="image" src="https://github.com/user-attachments/assets/f667a944-b2b3-488b-a643-33c57e614ddc" />

    - 유효 비트가 0인 페이지에 접근하려고 하면?

      - 페이지 폴트(page fault)라는 인터럽트 발생

        <img width="1498" height="298" alt="image" src="https://github.com/user-attachments/assets/01b85666-aa8b-48f9-9bef-272711434297" />

  - 보호 비트 (페이지 보호 기능을 위해 존재하는 비트)

    <img width="1792" height="644" alt="image" src="https://github.com/user-attachments/assets/33a1b572-9c41-4cd5-abcd-2109f508a269" />

  - 참조 비트 (CPU가 이 페이지에 접근한 적이 있는지 여부)
  
  - 수정 비트 (= dirty bit, CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부)

    - 수정된 페이지는 스왑 아웃될 때, 보조기억장치에도 쓰기 작업을 거쳐야 한다.

      <img width="1574" height="466" alt="image" src="https://github.com/user-attachments/assets/0b5e2883-8706-4052-bd47-fe5cb366a8bb" />


### 내부 단편화 (Internal Fragmentation)

✅ 페이징은 외부 단편화 문제를 해결할 수는 있지만, 내부 단편화라는 또 다른 문제를 야기할 수 있다.

  - 페이지 크기가 10KB, 프로세스 크기 108KB?
 
  - 2KB : 내부 단편화
 
  - 하나의 페이지 크기보다 작은 크기로 발생

    <img width="1182" height="678" alt="image" src="https://github.com/user-attachments/assets/bb3ab6c9-761b-4632-9145-8288de8922ed" />

### PTBR 

- 프로세스마다 페이지 테이블이 있고, 각 페이지 테이블은 CPU 내의 프로세스 테이블 베이스 레지스터 (PTBR)가 가리킨다.

  <img width="1258" height="774" alt="image" src="https://github.com/user-attachments/assets/6599a624-7b28-450f-ba19-f13e477ac382" />

- 페이지 테이블이 메모리에 있으면 메모리 접근 시간이 2배로 늘어난다

  - 페이지 테이블 참조 1번 + 페이지 참조하기 위해 1번
 
  - 이를 해결하기 위해 TLB (Translation Look-aside Buffer) 라는 페이지 테이블의 캐시 메모리가 사용된다.
  
    <img width="880" height="344" alt="image" src="https://github.com/user-attachments/assets/1b109d7c-f5b8-44fc-b641-1dfc10ad2eee" />

### TLB

- TLB : CPU 곁에 페이지 테이블의 캐시 메모리

- 페이지 테이블의 일부를 가져와 저장

<img width="1498" height="630" alt="image" src="https://github.com/user-attachments/assets/84afaa37-ab58-42cc-a476-4433e7239c1f" />

- CPU가 접근하려는 논리 주소의 페이지 번호가 TLB에 있다면? TLB 히트

  - 메모리 접근 1번
 
- CPU가 접근하려는 논리 주소의 페이지 번호가 TLB에 없다면? TLB 미스

  - 메모리 접근 2번
 
  - 메모리 접근 횟수를 낮추려면 TLB 히트율을 높여야 한다.

<img width="1464" height="538" alt="image" src="https://github.com/user-attachments/assets/5f502ffe-b175-442d-b3bb-08f41de5103d" />


### 페이징에서의 주소 변환

- 특정 주소에 접근하고자 한다면 어떤 정보가 필요할까?

  - 어떤 페이지/프레임에 접근하고 싶은지
 
  - 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지

  <img width="1530" height="672" alt="image" src="https://github.com/user-attachments/assets/fb437880-e022-455f-9a65-4f513e70473a" />

### 페이징 주소 체계

- 페이징 시스템에서의 논리 주소 

  - <페이지 번호 (page number) ,변위 (offset)>

  - <페이지 번호, 변위>로 이루어진 논리 주소는 페이지 테이블을 통해 <프레임 번호, 변위> 로 변환된다.
    
  <img width="1572" height="684" alt="image" src="https://github.com/user-attachments/assets/31b2e70a-e644-4742-857e-361c2bd312ce" />
 
  


## 페이지 교체 알고리즘

- **요구 페이징** : 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법

- 요구되는 페이지만 적재하는 기법

  <img width="1780" height="480" alt="image" src="https://github.com/user-attachments/assets/4747e452-e948-4974-882c-02525e287bdb" />

- 요구 페이징 기법으로 페이지들을 적재하다보면 언젠가 메모리가 가득 차게 된다.

- 당장 실행에 필요한 페이지를 적재하려면 적재된 페이지를 보조기억장치로 내보내야 한다.

- 이 떄 어떤 페이지를 내보낼지 결정하는 방법(알고리즘)이 페이지 교체 알고리즘!

- 페이지 교체 알고리즘의 성능 = 페이지 폴트의 발생 빈도

- 좋은 페이지 교체 알고리즘 = 페이지 폴트가 적은 알고리즘

- 페이지 폴트가 발생하면 보조기억장치에 접근해야 해서 성능 저하

### 대표적인 페이지 교체 알고리즘

1. FIFO 페이지 교체 알고리즘

   - 가장 단순한 방식
  
   - 메모리에 가장 먼저 올라온 페이지부터 내쫗는 방식
  
   <img width="1804" height="840" alt="image" src="https://github.com/user-attachments/assets/f0a5c74c-d3a6-4ff8-83b9-641ccd71a3fc" />

2. 최적 페이지 교체 알고리즘

   - 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
  
   - 가장 오래 사용되지 **않을** 페이지 교체
  
   - 메모리에 오래 남아야 할 페이지는 자주 사용될 페이지
  
   - 메모리에 없어도 될 페이지는 오랫동안 사용되지 않을 페이지

    <img width="1588" height="802" alt="image" src="https://github.com/user-attachments/assets/dd3c0fd5-1af7-4eda-89fd-f1e90c90f966" />

   - 앞으로 가장 적게 사용할 페이지를 미리 예측하기 어려워서 실제 구현이 어렵다
  
   - 다른 페이지 교체 알고리즘 성능을 평가하기 위한 하한선으로 간주
  
4. LRU 페이지 교체 알고리즘
  
   - 가장 오래 사용되지 **않은** 페이지 교체

    <img width="1378" height="610" alt="image" src="https://github.com/user-attachments/assets/fb11f8aa-ccfb-41d5-92b7-cf2decfee47b" />

      - LFU 페이지 교체 알고리즘 : 가장 적게 사용한 페이지를 교체하는 알고리즘
  
- 페이지 폴트가 자주 발생하는 이유

  - 나쁜 페이지 교체 알고리즘을 사용해서
 
  - 프로세스가 사용할 수 있는 프레임 자체가 적어서
 
    <img width="1164" height="562" alt="image" src="https://github.com/user-attachments/assets/2d7d0230-cc9c-44aa-86c0-a248bd33ca15" />

- **스래싱 (thrashing)** : 프로세스가 실제로 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능(CPU 이용률)이 저하되는 문제

  <img width="1920" height="678" alt="image" src="https://github.com/user-attachments/assets/c22736de-d143-406a-abc9-f4da5e87fc9d" />

  - 스레싱이 발생하는 이유
 
    - 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문
   
    - 각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고, 프로세스들에게 적절한 프레임을 할당해주어야 한다. 

<hr>

# 6. 파일 시스템

- 보조기억장치의 정보를 파일 및 디렉터리(폴더)의 형태로 저장하고 관리할 수 있도록 하는 운영체제 내부 프로그램.

## 파일과 디렉터리

### 파일

### 디렉터리

### 파일 할당

## 파일 시스템

### 아이노드 기반 파일 시스템

### 마운트


# Reference

https://www.youtube.com/watch?v=isj4sZhoxjk

https://velog.io/@alsgur/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%A3%BC%EC%86%8C-%EA%B3%B5%EA%B0%84-%EB%AC%BC%EB%A6%AC-%EC%A3%BC%EC%86%8C%EC%99%80-%EB%85%BC%EB%A6%AC-%EC%A3%BC%EC%86%8C

