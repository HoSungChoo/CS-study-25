# 네트워크 계층 - IP

- 물리 계층, 데이터 링크 계층은 LAN을 위한 기술이다.

- 반면 네트워크 계층은 LAN을 넘어 다른 네트워크와 통신을 주고받을 때 필요한 기술이다.
- 네트워크 계층에서 가장 핵심적인 프로토콜인 IP와 이를 중심으로 진행되는 네트워크 통신에 대해 알아보자.

## IP의 목적과 특징

- IP는 주소 지정, 단편화라는 목적을 가지고 있다.

- IP는 신뢰할 수 없는 통신과 비연결형 통신이라는 특징을 가진다.

IP의 목적 - 주소 지정

- 네트워크 통신 과정에서 호스트를 특정함을 의미한다. 이는 IP 패킷 헤더의 송신지, 수신지 IP address를 통해 알 수 있다.(192.168.0.1과 같이 표기되며, 점으로 구분된 숫자를 옥텟이라고 한다.)

- 추가적으로 IP만으로 수신인을 특정하기 어렵다. MAC 주소가 추가적으로 필요한데, IP 주소로 네트워크를 찾고 MAC 주소로 특정 수신인을 찾는 방식을 이용한다.(네트워크를 찾는 과정에서 라우터라는 장비가 사용된다)
- 라우터는 IP 주소를 바탕으로 목적지까지 IP 패킷을 전달하는 네트워크 장치다. IP 패킷 전달 시, 최적의 경로를 결정하고 해당 경로로 패킷을 내보내는데, 이를 라우팅이라고 한다. 공유기 역시 라우팅을 수행할 수 있으므로 라우터의 일종이다.
- IPv6는 IPv4 고갈 문제로 나타난 주소 체계다. 16바이트로 주소를 표기할 수 있기 때문에, 사실상 주소 표기 제한이 없다.

IP의 목적 - 단편화

- 데이터를 여러 IP 패킷으로 올바르게 쪼개어 보내는 것을 의미한다.

- 패킷이 수용할 수 있는 최대 전송 단위를 Maximum Transmission Unit(MTU)라고 하는데, IP 패킷의 크기가 MTU를 넘어갈 경우, 이를 분할한 뒤 여러 개로 전송한다.(MTU의 최대 크기는 1500바이트다)
- 분할된 패킷은 도착지에서 합쳐진다. 이 때, 식별자와 단편화 오프셋 플래그가 사용된다.
- 잦은 단편화는 많은 네트워크 비용을 야기하며, 이를 회피하기 위해 “경로 MTU 발견” 기술을 이용한다.
- 해당 기술은 패킷을 주고받을 경로에 존재하는 모든 호스트의 처리 가능 MTU 크기를 탐지하고 최대 MTU 값으로 패킷을 송수신하는 원리를 가진다.

IP 패킷의 구조

- IP 패킷을 통해 한 번에 전송할 수 있는 논리적 크기는 64KB다. 보통 64KB 크기의 데이터를 한번에 보내지 않고 MTU 크기로 나누어 보낸다.

- 식별자(16bit) : 특정 패킷이 어떤 데이터에서 분할된 패킷인지 식별하는 용도
- 플래그(3bit) : Reserved, DF, MF 형태의 3비트로 구성되어 있다.
    - Reserved : 항상 0값을 가진다.

    - DF : 단편화 불가 표기를 나타낸다. 1은 단편화 하지 말라는 경고를 의미한다.
    - MF : 해당 패킷이 단편화된 패킷 중 마지막인지 여부를 나타낸다. 0이면 마지막 조각이다.
- 단편화 오프셋(13bit) : 원래 데이터로부터 몇 바이트 떨어져있는지 나타낸다. 표기된 크기 * 8바이트 만큼 떨어져있다.
- Total Length(16bit) : 패킷의 전체 길이를 의미한다. 2^16(=65536) 숫자를 표기할 수 있다. 즉, 하나의 패킷은 최대 64KB 크기를 가진다.

<img width="971" height="547" alt="1" src="https://github.com/user-attachments/assets/adc4ad4e-f7d8-4a4e-9a92-f26bcb12059d" />


신뢰할 수 없는 프로토콜

- 패킷이 수신지까지 제대로 전송되었다고 보장하지 않는 프로토콜을 의미한다. 최선형 전달이라고도 부른다.

- IP 프로토콜이 포함되며, 주로 TCP와 UDP의 존재 목적과도 연결된다.

비연결형 프로토콜

- 받는 대상의 수신 가능 여부를 고려하지 않는 프로토콜을 의미한다.

- IP 프로토콜이 포함되며, 이와 반대로 TCP는 연결형 프로토콜이다.

## IP 주소의 구조

IP 주소

- IP 주소는 네트워크 주소와 호스트 주소로 구성되어 있다.

- 네트워크 주소는 네트워크 ID, 네트워크 식별자 등으로 불리며, 호스트가 속한 네트워크를 특정하기 위함이다.(즉, 네트워크는 호스트가 어떤 지역에 있는지 특정하는 주소)
- 호스트 주소는 호스트 ID, 호스트 식별자로 불리며 네트워크에 속한 호스트를 특정하기 위함이다.(즉, 호스트 주소는 네트워크라는 지역 안에서 대상을 특정하는 주소)
- 하나의 IP 주소 내에서 네트워크 주소와 호스트 주소는 유동적으로 할당될 수 있다. 할당 방식을 분류한 것을 클래스풀 주소 체계라고 한다.

<img width="904" height="514" alt="2" src="https://github.com/user-attachments/assets/f296b6ed-56c2-44f7-96a0-142e85728de2" />


클래스풀 주소 체계

- 클래스는 네트워크 유형별로 IP 주소를 분류하는 체계다. 따라서, 클래스를 통해 네트워크 주소와 호스트 주소의 크기가 얼마인지 알 수 있다.

- 클래스는 A~E로 구분되어 있으며, 주로 A와 B와 C가 사용된다. D와 E는 멀티캐스트를 위해 사용된다.
    - 클래스 A는 ‘0’으로 시작하며 8비트의 네트워크 주소 + 24비트의 호스트 주소로 구성되어 있다. 즉, 하나의 네트워크에 많은 호스트 주소가 할당될 때 사용된다.
    
    - 클래스 B는 ‘10’으로 시작하며 16비트의 네트워크 주소 + 16비트의 호스트 주소로 구성되어 있다. 즉, 네트워크 주소와, 호스트 주소에 적당한 밸런스가 필요할 때 사용된다.
    - 클래스 C는 ‘110’으로 시작하며 24비트의 네트워크 주소 + 8비트의 호스트 주소로 구성되어 있다. 즉, 많은 네트워크 주소가 필요할 때 사용된다.
        
        <img width="591" height="333" alt="3" src="https://github.com/user-attachments/assets/c1d95575-2487-4aef-a0db-a19e6e58c788" />

        
- 호스트 주소 공간을 모두 사용할 수는 없다. 호스트 주소가 전부 0인 IP 주소는 네트워크 자체를 의미하는 주소를 의미하며, 주소가 전부 1인 IP 주소는 브로드캐스트를 위한 주소다.

- 특수한 목적으로 예약된 IP 주소도 존재한다.
    - [특정 목적을 가진 IP 주소 모음](https://en.wikipedia.org/wiki/Reserved_IP_addresses)

클래스리스 주소 체계와 서브넷 마스크

- 클래스풀 주소 체계는 IP 주소 낭비 문제를 안고있으며, 클래스리스 주소 체계는 이를 해결해준다.

- 클래스리스 주소 체계는 네트워크와 호스트 주소 체계를 구분하기 위해 서브넷 마스크를 이용한다.
- 서브넷 마스크는 네트워크 주소를 1, 호스트 주소를 0으로 표기한 비트열이다.
- 서브넷은 일반 네트워크 주소 내에 포함된 부분집합 개념이다. 일반 네트워크 주소를 쪼개서 사용한다.
- CIDR 표기법은 IP 주소 / 서브넷 마스크상의 1의 개수를 의미한다. 표기하기 편하다. x.x.x.x/30은 11111111111111111111111111111100 이라는 서브넷 마스크를 이용한 것과 같다.

## 공인 IP 주소와 사설 IP 주소

- IP는 공인, 사설로 분류되며, 호스트는 공인, 사설 IP를 둘 다 사용할 수 있다.

- 공인 IP 주소는 고유 IP 주소로 네트워크 간 통신에 사용된다.(즉, 공인 IP는 하나의 네트워크를 담당할 수 있다)
- 사설 IP 주소는 사설 네트워크에서 사용하기 위한 IP 주소다. 사설 IP 주소는 다른 네트워크 상의 사설 IP와 공유될 수 있으며, 특별히 예약된 IP 주소 공간이 있다.

![4](https://github.com/user-attachments/assets/df502ab3-cbaa-4c8c-bb9e-e64f23b611d9)


## IP 주소의 할당

- 정적 할당, 동적 할당으로 구분된다.

정적 할당

- 정적 할당은 수작업으로 진행된다.

- IP 주소, 서브넷 마스크, 게이트웨이, DNS 주소가 필요하다.
- 게이트웨이는 보통 라우터로, 자신의 서브넷과 다른 네트워크를 연결하는 역할을 한다.
- DNS 주소는 도메인 이름을 IP로 변환해 주는 서버의 IP 주소를 의미한다.

동적 할당

- DHCP 프로토콜을 이용해 자동으로 IP 주소를 부여한다.

- DHCP 서버는 라우터에 위치하며 할당 가능한 IP를 관리한다. 또한, 호스트의 요청에 동적 IP 주소를 반환한다.
- 동적 IP 주소는 임대기간이 정해져있으며, 요청마다 다른 주소를 받을 수 있다. 임대는 갱신이 최대 2번까지 가능하다.

## IP 전송 특징의 보완: ICMP

- IP 프로토콜은 신뢰할 수 없는 비연결형 프로토콜이다. 이는 성능을 위함이다.

- IP 프로토콜의 비연결성으로 인한 한계점을 개선해주는 프로토콜을 ICMP라고 한다.
- ICMP는 IP 패킷의 전송 과정에 대한 피드백 메세지를 받는 방식으로 작동한다. 해당 메세지를 통해 “전송 과정에서 발생한 오류” 혹은 “네트워크에 대한 진단 정보” 등 결과를 알 수 있다.
- ICMP는 IP 패킷 전송에 대한 보고를 하는 기능이므로 근본적인 신뢰성을 개선하진 못한다.(후행성이다)

## IP 주소와 MAC 주소의 대응: ARP

- ARP 프로토콜은 IP 주소를 기반으로 MAC 주소를 유추할 수 있는 기능을 가진다.

- ARP 프로토콜은 브로드 캐스트 기능을 이용해 MAC 주소를 유추한다. 즉, 한 네트워크 내 모든 호스트에 ARP 요청 메세지를 전송하고 전송 대상에게 ARP 응답 메세지를 받아 MAC 주소를 추출한다.
- 호스트는 ARP table을 통해 <IP address, MAC address>를 캐싱한다. 이 덕분에 호스트 통신 시 전송 성능을 개선할 수 있다.

# 전송 계층 - TCP와 UDP

## TCP와 UDP의 목적과 특징

포트를 통한 프로세스 식별

- 하나의 호스트가 여러 개의 프로세스를 실행할 수 있고, 이에 대한 구분이 필요하다. → 이를 포트로 구분하며, 즉 호스트는 궁극적으로 IP address + port numer 라는 목적지로 데이터를 송수신하게된다.

- 이러한 포트 번호 정보는 전송 계층에서 입력하며, TCP와 UDP 모두 헤더에 포트 번호 입력 칸이 존재한다.
- 포트 번호는 16비트로 표현되며, 웰노운 포트, 등록된 포트, 동적 포트로 구분된다.
    - 웰노운 포트는 범용적으로 사용되는 프로토콜이 주로 사용하는 포트 목록이다. SSH는 22, HTTP는 80, HTTPS는 443 이 대표적이다. (0 ~ 1023번 포트가 사용된다)

    - 등록된 포트는 흔하게 사용되는 프로토콜에 할단된 포트 목록이다. OpenVPN은 1194, MySQL은 3306, Redis는 6379가 사용된다. (1024 ~ 49511번 포트가 사용된다)
    - 동적 포트는 자유롭게 사용할 수 있는 포트다. 브라우저 프로그램의 경우, 동적 포트 내에서 임의의 포트를 할당 받는 경우가 많다. (49512 ~ 65535번 포트가 사용된다)

NAT와 포트

- NAT는 사설 IP 주소와 공인 IP 주소를 양방향으로 전환해주는 기술이다. 하나의 공인 IP 주소에는 여러 개의 사설 IP 주소가 할당될 수 있다.

- 이 과정에서 공인 IP를 사설 IP로 변경하는 경우, 사설 IP를 구분해야 하는데, 이 때 포트 번호가 사용된다. 이러한 기술을 NAPT라고 한다. (현대의 NAPT는 보통 NAT라고 부른다)
- 공인 IP와 사설 IP는 라우터 등 게이트웨이에서 테이블 형태로 관리한다.

비신뢰성과 비연결형 보장

- TCP
    - 신뢰, 연결형 프로토콜이다.

    - 신뢰성 확보를 위해 상태 관리, 흐름제어, 오류 제어, 혼잡 제어 기능을 제공한다.
    - 연결성 확보를 위해 핸드 쉐이크 기반 연결 종료 과정을 가진다.
    - 신뢰, 연결성 구축 때문에 UDP보다 송수신 속도가 느리며, 많은 정보를 제공해야 하기 때문에 헤더의 크기가 비대하다.(대부분의 필드가 신뢰성과 연결성 확보에 사용된다)

- TCP 헤더
    - TCP 헤더의 구성은 다음과 같다.

    - 순서 번호
        - TCP 패킷의 순서를 보장하기 위해 세그먼트 첫 바이트에 매겨진 번호다.
        - 첫 패킷을 전송할 때는 임의의 수를 전송하며, 이후에는 임의의 수 + 전송할 페이로드의 바이트 위치를 보낸다.
        - 순서 번호를 통해 현재 주고받는 TCP 세그먼트가 송수신하고자 하는 데이터의 몇 번째 바이트에 해당하는지 알 수 있다.

    - 확인 응답 번호
        - 상대 호스트가 보낸 세그먼트에 대한 응답으로, 다음으로 수신하길 기대하는 순서 번호다. 즉, 해당 패킷을 잘 받았고, 다음 패킷을 내놓으라는 신호다.

        - 응답 송신 시, ACK 플래그를 1로 설정한 뒤, 응답 받은 순서 번호 + 1 크기의 숫자를 반환한다.
        - 이를 통해, 쪼개진 패킷의 순서 정리와 누락 여부를 검즘할 수 있다.

    - 순서 번호 + 확인 응답 번호 예시(A, B 호스트)

        - 1000 바이트의 페이로드를 10번 쪼개 보낼 때, A는 처음에 임의의 수 100000을 순서 번호에 담아 전송한다.(결론 100000 전송)

        - B는 이를 확인하고 다음에 받아야 할 데이터 위치를 송신자에게 전송한다. B는 송신 받은 TCP 헤더를 통해 페이로드의 크기를 확인할 수 있다.(즉, 데이터의 크기가 100 바이트임을 알 수 있다) 이 때, 확인 응답 번호에 100100, ACK flag는 1로 담아 A에게 전송한다.
        - A는 이를 받은 뒤, 확인 응답 번호인 100100 값과 해당 페이로드를 송신자에게 전송한다.
        - 같은 방식으로 반복된다.
    - 제어 비트
        - 현재 세그먼트에 대한 부가 정보로, 8개의 비트로 구성된다.
        - ACK : 세그먼트 승인 여부 확인

        - SYN : 연결 수립 확인
        - FIN : 연결 종료 확인
    
    <img width="1280" height="425" alt="5" src="https://github.com/user-attachments/assets/0e59f18d-711f-4412-b8a4-799f719ca86d" />

    
- UDP
    - 비신뢰, 비연결형 프로토콜이다.

    - 전송 속도가 빠르며, 헤더가 간단하다

- UDP 헤더
    - 송신지 포트, 수신지 포트 : 송수신지 포트 번호

    - 길이 : 헤더를 포함한 UDP 패킷의 바이트 크기
    - 채크섬 : 데이터그램 훼손 여부 확인
    
    <img width="725" height="192" alt="6" src="https://github.com/user-attachments/assets/6c5c6eca-6391-4fa6-a11e-5ef74498ed8f" />

## TCP의 연결부터 종료까지

TCP의 연결

- TCP는 신뢰성을 위해 호스트 간의 연결과 종료 과정을 거친다. 이 때 핸드쉐이크 개념이 사용된다.

액티브, 패시브

- 액티브 : 처음 연결 및 종료를 시작하는 과정

- 패시브 : 요청을 수신한 뒤, 그에 대한 연결 및 종료를 수립하는 과정

TCP의 연결 수립

- 호스트간 연결 수립을 위해 3 웨이 핸드쉐이크 기술이 사용된다.

- 과정은 다음과 같다.

    - A → B : SYN 세그먼트 전송

        - 호스트 A는 B에게 SYN 세그먼트가 1인 패킷을 전송한다.

        - 이 때, 호스트들의 포트번호, 순서 번호, 제어 비트 등이 전송된다.
        - 여기서 순서 번호는 임의의 수다.
    - B → A : ACK + SYN 세그먼트 전송
        - 호스트 B는 A에서 ACK + SYN 세그먼트가 각각 1인 패킷을 전송한다.

        - 이 때, 호스트들의 포트 번호, 순서 번호, 확인 응답 번호, 제어 비트 등이 전송된다.
        - 여기서 확인 응답 번호는 이전 세그먼트의 순서 번호 + 1이다.
        - 또한, 새로운 임의의 순서 번호를 전송한다.

    - A → B : ACK 세그먼트 전송
        - 세그먼트를 받은 호스트 A는 ACK 비트가 1로 설정된 세그먼트를 호스트 B에 전송한다.

        - 이 때, 확인 응답 번호에는 B로부터 받은 순서 번호 + 1 값이 저장된다.
        - 또한, 순서 번호에는 기존 A의 순서 번호 + 1 값이 저장된다 (왜 있는지 모르겠다)

- 호스트 A는 액티브 오픈, 호스트 B는 패시브 오픈

<img width="550" height="351" alt="7" src="https://github.com/user-attachments/assets/a5980a4e-75ff-4992-94b6-64d4fffe629d" />

TCP의 제어

- TCP는 패킷의 신뢰성을 보장하기 위해 오류 제어, 흐름 제어, 혼잡 제어 기능을 이용한다.

- 오류 제어

    - 수신자에게 중복된 ACK 세그먼트가 도착했을 때, 세그먼트 전송이 잘못됨을 인지한다.

    - 타임 아웃이 발생했을 때, 잘못 전송된 세그먼트가 존재함을 인지한다. 송신자는 TCP 세그먼트를 송신할 때, 모두 재전송 타이머라는 값을 유지하는데, 해당 타이머가 타임아웃될 때 까지 ACK 세그먼트를 받지못하면 TCP 세그먼트를 재전송한다.

    - 파이프라이닝 전송은 기존 TCP의 송수신 규칙의 한계점을 보완한 전송 방식이다. 한번에 여러 세그먼트를 전송하는 방식을 이용한다.

- 흐름 제어
    - 수신 호스트가 한 번에 받아 처리할 수 있는 만큼만 전송함을 의미한다.

    - 수신 호스트의 전송량은 TCP 수신 버퍼의 크기에 의해 결정된다. 또한, 송신 호스트는 수신 호스트의 수신 윈도우 필드를 통해 처리량을 확인하고 전송한다. (즉, 수신 호스트가 관리한다)

- 혼잡 제어
    - 송신 호스트는 전송한 세그먼트에 오류가 발생하면(즉, 오류 제어와 같은 상황이 발생하면) 세그먼트의 전송량을 혼잡 없이 전송할 수 있을 정도로 조절한다.

    - 이 전송량을 혼잡 윈도우라고 하며, 값이 크면 한 번에 전송할 수 있는 세그먼트가 많음, 값이 작으면 세그먼트가 적음을 의미한다.

    - 혼잡 윈도우의 크기 조절 과정을 혼잡 제어 알고리즘이라고 한다. 대표적으로 AIMD가 존재한다

    - AIMD는 “합으로 증가, 곱으로 감소”를 의미하며, 세그먼트를 보내고 응답이 처리되면 혼잡 윈도우를 1씩 증가, 응답이 처리되지 않으면 절반으로 감소 방식으로 혼잡 윈도우를 관리한다.

    - 패킷을 전송하고 응답이 수신되기까지의 시간을 RTT라고 하며, AIMD는 이 RTT를 1씩 증가시키거나 절반으로 감소시킨다고 생각하면 된다.

TCP의 연결 종료

- 호스트간 연결 종료를 위해 4 웨이 핸드쉐이크 기술이 사용된다.

- 과정은 다음과 같다.

    - A → B : FIN 세그먼트 전송

        - FIN 비트가 1인 세그먼트를 호스트 B에게 전송

        - 이는 A가 B에게 종료하라고 알리는 신호
    - B → A : ACK 세그먼트 전송
        - ACK 비트가 1인 세그먼트를 호스트 A에게 전송

        - 이는 B가 A에게 알겠다고 알리는 신호
    - B → A : FIN 세그먼트 전송
        - 호스트 B는 연결 종료 후 FIN 비트가 1인 세그먼트를 A에게 전송

        - 이는 연결이 실질적으로 종료됐음을 알리는 신호
    - A → B : ACK 세그먼트 전송

        - 호스트 A는 호스트 B의 연결 종료 확인 후 ACK 비트가 1인 세그먼트를 B에게 전송

        - 이는 연결이 실질적으로 종료됨을 인지했음을 알리는 신호

    - B의 종료
        - 호스트 B는 ACK 세그먼트 전송 후 특정 시간 뒤에 종료

        - 이는 아직 도착하지 못한 세그먼트를 기다리기 위함

- 호스트 A는 액티브 클로즈, 호스트 B는 패시브 클로즈

<img width="550" height="459" alt="8" src="https://github.com/user-attachments/assets/a10a446d-b37e-499a-8082-6a9c1f912ab0" />

## TCP의 상태 관리

- TCP는 상태를 유지하는 STATEFUL PROTOCOL이다.

- TCP는 다음과 같은 상태를 가진다.

<img width="367" height="446" alt="9" src="https://github.com/user-attachments/assets/018b81d1-5939-4ab1-9b92-f90b23b579dc" />

- 상태는 크게 3가지 항목으로 분류된다

    - 연결이 수립되지 않은 경우

        - CLOSED : 아무 연결이 없는 상태. 이 상태에선 액티브 오픈 호스트가 요청을 던져도 반응하지 않는다.

        - LISTEN : 연결 대기 상태(3 way handshake에서 첫 단계인 SYN 세그먼트를 대기하는 상태)
        - 보통 서버로 동작하는 패시브 오픈 호스트는 일반적으로 LISTEN 상태를 가지며 연결 요청을 기다린다

    - 연결 수립 과정
        - SYN-SENT : 액티브 오픈 호스트가 SYN 세그먼트를 보내고 응답을 기다리는 상태

        - SYN-RECEIVED : 패시브 오픈 호스트가 SYN + ACK 세그먼트를 보낸 뒤, ACK 세그먼트를 기다리는 상태
        - ESTABLISHED : 3 way hand shake가 끝난 뒤 연결이 수립된 상태

    - 연결 종료 과정
        - FIN-WAIT-1 : 액티브 클로즈 호스트가 연결 종료를 위해 FIN 세그먼트를 전송한 상태

        - CLOSE-WAIT : 패시브 클로즈 호스트가 FIN 세그먼트를 받고 ACK 세그먼트를 반환한 뒤 기다리는 상태
        - FIN-WAIT-2 : FIN-WAIT-1 상태에서 액티브 클로즈 호스트가 ACK 세그먼트를 받은 상태
        - LAST-ACK : CLOSE-WAIT 상태에서 FIN 세그먼트를 전송한 뒤 대기하는 상태
        - TIME-WAIT : 액티브 클로즈 호스트가 마지막 ACK 세그먼트를 전송한 뒤 접어드는 상태
        - CLOSED(미연결): TIME-WAIT이 되고 일정 시간이 지나면 CLOSED 상태가 된다. 이는 재전송, 미도착 세그먼트를 기다리기 위함이다.

---

## 고민점

같은 네트워크, 다른 네트워크 통신 시 어떤 흐름으로 진행되는가 ?

- 공통 과정

    - 캡슐화

        - 응용 계층 : 데이터의 용도(HTTP, FTP, ..)를 결정 + 데이터 입력

        - 전송 계층 : 데이터의 전송 방식을 결정(TCP, UDP) + 송수신지 PORT 입력
        - 인터넷 계층 : 데이터의 목적지 결정(IP) + 송수신지 IP 주소 입력. DNS 관여
        - 링크 계층 : 데이터의 식별 정보 결정 + 송수신지 MAC 주소 입력. ARP, RARP 관여
    - 역캡슐화

        - 캡슐화 과정을 반대로 진행하며 패킷의 정보 추출

- 같은 네트워크(LAN)의 경우

    - 송수신지의 네트워크 주소가 동일(IP 주소 유추 가능)

    - 브로드 캐스트를 통해 수신지의 MAC 주소 유추 가능

- 다른 네트워크(LAN)의 경우

    - DNS를 통해 수신지의 IP 주소 유추 가능
    
    - 라우터, 다른 네트워크의 호스트를 기반 ARP를 통해 MAC 주소 유추 가능(이 과정에서 MAC 주소는 동적으로 변경됨)

![10](https://github.com/user-attachments/assets/84a1bf8a-61ad-4ef7-b0ad-c41768aac5c3)

---

fragment offset 공부하기 : MTU의 크기가 달라질 때, 어떻게 변하는지 납득이 안됨
