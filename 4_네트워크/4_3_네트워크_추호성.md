# 응용 계층 - HTTP의 기초

## DNS와 URI/URL

DNS의 필요성 및 용어 정리
- IP 주소를 이용해 호스트를 식별하는 것은 그 특징을 기억하기 어렵다는 점, IP 주소가 언제든 바뀔 수 있다는 단점을 가진다 → IP 주소를 문자열과 대응시키는 방식을 이용한다.

- 도메인 네임 : www.naver.com과 같은 문자열 형태의 호스트 정보
- 네임 서버 : 도메인 네임에 대응되는 IP 주소를 저장하는 서버
- DNS 서버 : 도메인 네임을 관리하는 네임 서버
- 리졸빙 : 도메인 네임에 대응되는 IP 주소를 찾는 과정

도메인 네임으로 IP 주소를 찾는 과정

- 도메인 네임은 계층적 구조를 지닌다.

    - 도메인 네임에 대한 관리 체계를 도메인 네임 시스템(DNS)이라고 한다.

    - www.naver.com.는 . → com → naver → www 순서로 도메인 계층이 분류된다.
    - 여기서 .부터 각각 루트 도메인, 최상위 도메인, 2단계 도메인, .. 으로 불린다.
    - 이를 모두 포함한 도메인 네임을 전체 주소 도메인 네임(FQDN)이라고 부른다.
    - 다른 도메인이 포함된 도메인을 서브 도메인이라고 부른다.
- 네임 서버 역시 계층적 구조를 지닌다.

    - 네임 서버의 계층은 도메인 네임의 계층 구조를 따른다.

- 클라이언트는 도메인 네임을 입력할 경우 다음 과정을 거친다.

    - 로컬 네임 서버
        - 클라이언트가 가장 먼저 찾는 서버다.

        - ISP 혹은 공개 DNS 서버에서 해당 서버의 주소를 제공해준다.
        - 요청을 받은 도메인 네임이 캐시에 존재할 경우 IP 주소를 반환해준다.(이를 DNS 캐시라고 한다)
        - 캐시에 존재하지 않을 경우, 루트 네임 서버로 요청을 전송한다.
        - 목적에 따라 다르겠지만 전국에 몇 천대 배치되어 있다.

    - 루트 네임 서버
        - 루트 도메인에 대응되는 서버다.

        - 입력받는 도메인 네임 중 최상위 도메인을 읽고 이에 대응하는 TLD 네임 서버의 주소를 반환한다.
    - TLD 네임 서버
        - 최상위 도메인에 대응되는 서버다.

        - 입력받은 도메인 네임 중 다음 계층의 도메인을 읽고 이에 대응하는 네임 서버의 주소를 반환한다.
    - 네임 서버
        - 기타 도메인에 대응되는 서버다.

        - 입력받은 도메인 네임 중 다음 계층의 도메인을 읽고 이에 대응하는 네임 서버의 주소를 반환한다.
        - 입력받은 도메인 네임이 계층의 마지막인 경우, 이에 대응하는 IP 주소를 반환한다.

    - 즉, 클라이언트는 로컬 네임 서버에 IP 주소를 요청하고, 로컬 네임 서버는 루트 네임 서버 → TLD 네임 서버 → 네임 서버 → .. 를 재귀적으로 반복하며 IP 주소를 찾아 로컬 네임 서버에 전달하고 이를 클라이언트에 반환한다.

$$$$ 그림 $$$$

DNS 캐시

- 요청한 도메인 네임을 바로 IP 주소로 변환하는 역할을 한다.

- 브라우저 캐시, OS 캐시, ISP 캐시, 권한 있는 네임 서버 캐시가 존재한다.

DNS 레코드 타입

- DNS 네임과 IP 주소를 연결하는데 필요한 데이터

- A 레코드 : 도메인 네임 / IPv4 주소 대응
- AAAA 레코드 : 도메인 네임 / IPv6 주소 대응
- CNAME 레코드 : 도메인 네임 별칭
- NS 레코드 : 특정 호스트의 IP 주소를 찾을 수 있는 네임 서버 대응
- MX 레코드 : 해당 도메인과 연동되어 있는 메일 서버 대응

자원과 URI/URL

- ‘자원’은 네트워크 상의 메세지를 통해 주고받는 대상을 의미한다.

- URI는 ‘자원’을 식별하는 방법이며 이름 혹은 위치를 기반으로 식별한다.
- 이름으로 자원을 식별하는 것을 URN, 위치로 자원을 식별하는 것을 URL이라고 한다.
- URN은 많이 쓰이진 않지만, 자원에 고유 이름을 붙여 사용한다.

URL 구조

`http://www.example.com:80/api/there?name=hosung#nose`

해당 URL은 다음과 같은 구조로 구성되어있다.

- scheme (`http`)

    - 자원에 접근하는 방법

    - 보통 프로토콜을 명시한다.
- authority (`www.example.com:80`)
    - IP 주소 혹은 도메인 네임을 명시한다.

    - 포트 번호를 추가할 수 있다

- path (`/api/there`)

    - 자원이 위치하는 경로를 명시한다.
- query (`name=hosung`)
    - 자원 식별을 위한 추가 정보를 명시한다.

    - 예를 들어, 특정 문자열 포함 여부 혹은 내림차순 등 이 존재한다.
    - ?와 & 를 이용해 표현한다
- fragment (`nose`)
    - 자원의 특정 부분을 기리키기 위해 사용된다.

    - 예를 들어 section-1.1.2를 명시하여 html 파일의 특정 부분을 가리킬 수 있다.

## HTTP의 특징과 메세지 구조

HTTP의 특징

- 요청 응답 기반 프로토콜
    - HTTP는 요청과 응답을 기반으로 동작한다.

    - 요청 메세지와 응답 메세지는 다른 형태를 가진다.
- 미디어 독립적 프로토콜
    - HTTP는 자원을 주고받는 수단의 역할만 한다. 즉, 자원의 특성과 무관하다.

    - 미디어 타입에 종속되지 않은 미디어 독립적 프로토콜이다.
    - 미디어는 타입과 서브타입을 매개로 구분된다. 궁금하면 각자 찾아보도록

- 무상태성 프로토콜
    - 서버는 HTTP 요청을 보낸 클라이언트 관련 상태를 기억하지 않는다.

    - 무상태성은 특정 서버에 종속되지 않는다는 특징을 가지며, 서버 확장성, 부하 문제 개선, 고가용성이라는 장점을 가진다.
- 지속 연결 프로토콜
    - HTTP 1.1 버전 이후 지속 연결(keep-alive) 기능을 갖게 되었다.

    - 지속 연결을 통해 비 지속 연결보다 빠른 속도로 여러 HTTP 요청과 응답을 처리할 수 있게됐다.

$$$$ 그림 $$$$

HTTP 버전별 특징

- HTTP 1.1
    - 평문 기반 송수신

    - 지속 연결 기능 지원
    - 파이프라이닝 지원(요청에 대한 응답을 기다리지 않고 새로운 요청을 보낼 수 있음) 그러나 현재 HOL 문제 및 중간 서버의 미지원 문제로 현재 잘 쓰이지 않음(크롬, 파폭 모두 지원 중단)

- HTTP 2.0
    - 바이너리 데이터 기반 송수신 : 평문이 아닌 바이너리 기반 송수신 지원.

    - 헤더 압축 : 헤더를 압축하여 네트워크 이용 효율을 높일 수 있음
    - 서버 푸시 : 클라이언트가 요청하지 않더라도 미래에 필요할 것으로 예상되는 자원을 미리 전송하는 기능(최근 브라우저에서 제거하는 추세)
    - HTTP 멀티 플렉싱
        - 여러 개의 독립적인 스트림을 바탕으로 요청-응답 메세지를 병렬적으로 주고 받는 기술

        - 스트림은 TCP 연결 하나 안에서 가상의 요청-응답 채널을 나눈 개념이지, 실제로 물리적 별도 라인을 뚫는 건 아니다
        - Application Layer에서의 HOL 문제는 해결했지만, 패킷 손실과 같이 Transport Layer에서의 HOL 문제는 해결하지 못했다. 추후 QUIC에서 해결했다.

- HTTP 3.0
    - UDP를 토대로 하는 QUIC 프로토콜을 기반으로 동작한다. 속도 측면에서 큰 개선을 이뤘다.

HTTP 메세지 구조

- HTTP 메세지는 시작 라인 → 필드 라인 → 메세지 본문으로 구성되어 있다.

시작 라인

- 시작 라인은 요청 라인과 상태 라인으로 구성되어 있다.

- 요청 라인은 `“메서드” “요청 대상” ”HTTP 버전”` 으로 구성되어 있다.
    - 메서드 : GET, POST 등

    - 요청 대상 : URL path. 자원의 위치 명시
    - HTTP 버전 : 사용된 HTTP 버전
- 상태 라인은 `“HTTP 버전” “상태 코드” “이유 구문”` 으로 구성되어 있다.
    - HTTP 버전 : 사용된 HTTP 버전

    - 상태 코드 : 요청에 대한 결과. 3자리수로 표현
    - 이유 구문 : 상태 코드에 대한 문자열 형태의 설명
    - 예를 들어, `HTTP/1.1 200 OK`

필드 라인

- HTTP 헤더 명시. HTTP 헤더는 헤더 이름 + 헤더 값으로 구성된다.

- 예를 들어, `Content-Type: text/html`, `Content-Length: 648`

## HTTP 메서드와 상태 코드

HTTP 메서드

- GET, POST, PUT, DELETE, HEAD, PATCH 등이 존재한다.

- 각 메서드들마다 특정한 동작 형태가 요구된다.

HTTP 상태 코드

- 요청의 결과를 나타내는 3자리수 코드를 의미한다.

- 100번대

    - 정보성 상태 코드
- 200번대

    - 성공 상태 코드
- 300번대
    - 리다이렉션 상태 코드

    - 요청한 자원의 위치가 바뀐 경우, 300번대 코드와 함께 Location 헤더를 통해 변경된 주소를 전송한다.
    - 리다이렉션은 자원에 따라 영구적 리다이렉션, 일시적 리다이렉션으로 구분된다.
    - 요청을 전송하고 300번대 응답이 오면 요청된 자원의 위치와 형식이 바뀌는데, 여기서 요청 메서드도 변경될 가능성이 있다. 변경 가능성에 따라 요청 코드도 변경된다.
        
        
        |  | 변경 가능성 있음 | 변경 가능성 없음 | GET으로 고정 |
        | --- | --- | --- | --- |
        | 영구적 리다이렉션 | 301 | 308 |  |
        | 일시적 리다이렉션 | 302 | 307 | 303 |
- 400번대
    - 클라이언트에 잘못이 있음을 나타내는 상태 코드

    - 이 중, 401번은 요청한 자원에 대한 유효한 인증이 없음을 의미하고, 403번은 자원에 대한 접근 권한이 충분하지 않음을 의미한다. (인증과 인가 문제)
- 500번대

    - 서버에 잘못이 있음을 나타내는 상태 코드

    - 500은 요청을 처리할 수 없음(주로 서버 내부 문제)
    - 502는 중간 서버의 통신 오류(LB와 같은 매개 서버 문제)

## HTTP 주요 헤더

요청 메세지에서 주로 활용되는 HTTP 헤더

- Host
    - 요청을 보낼 호스트가 명시되는 헤더 (요청을 받는 대상 호스트가 명시된다)

- User-Agent

    - 요청 메세지를 보낸 클라이언트의 프로그램과 관련한 정보가 명시

    - 모질라 호환 여부, 운영체제, 렌더링 엔진 등 여러 정보가 존재한다.
- Referer
    - 클라이언트가 요청을 보낼 때 머무르던 URL이 명시되어 있다.

    - 이를 통해 클라이언트의 유입 경로를 파악할 수 있다.

응답 메세지에서 주로 활용되는 HTTP 헤더

- Server
    - 서버 호스트와 관련되 정보 명시

    - 예를 들어, Apache/2.4.1 (Unix)
- Allow
    - 처리 가능한 HTTP 헤더 목록을 반환

    - 405 상태 코드와 같이 사용된다.(가능한 Http Method Type을 명시)

- Location
    - 클라이언트에게 자원의 위치를 알려주기 위해 사용된다

    - 주로 리다이렉션이 발생했을 때, 새로운 자원이 생성되었을 때 사용된다.

요청, 응답 메세지에서 주로 활용되는 HTTP 헤더

- Date : 메세지 생성 시간

- Content-Length : 메세지 길이
- Content-Type, Content-Language, Content-Encoding : 표현 헤더라고 부른다. 타입, 언어, 인코딩 종류가 적혀있다. 언어는 “언어-국가”로 표기될 수 있다.
- Connection : 송신 호스트가 원하는 연결 방식이다. keep-alive, close 등이 존재한다.

# 응용 계층 - HTTP의 응용

## 쿠키

쿠키

- HTTP의 무상태성 특성을 보완해주는 기술

- 서버에서 생성되며 클라이언트 측에 저장되는 key-value 형태의 데이터
- 서버가 쿠키를 전송해줄 경우, 클라이언트는 앞으로 해당 서버와 통신할 때 쿠키를 계속 담아서 전송해야 한다.
- 속성값을 포함할 수 있다. domain, path 등이 존재한다. 이는 서버가 클라이언트에 쿠키를 내려줄 때 설정할 수 있으며, 클라이언트가 서버에 쿠키를 보낼 때, 서버는 이를 확인하고 적절한 조치를 취할 수 있다.
- 보안 속성도 존재한다, Secure는 https 강제 옵션이며 httpOnly는 자바스크립트를 통한 쿠키의 접근을 제한한다.

웹 스토리지 : 로컬 스토리지와 세션 스토리지

- 웹 브라우저 내의 저장 공간

- 쿠키보다 더 큰 데이터를 저장하며, 서버와 분리되어 있다.(쿠키와 다른 점)
- 로컬 스토리지와 세션 스토리지가 존재한다.
- 로컬 스토리지는 영구 저장소며 세션 스토리지는 세션이 유지되는 동안 지속된다.

## 캐시

- HTTP 요청의 응답 부하 및 속도를 개선하기 위해 HTTP 캐시를 이용할 수 있다.

- HTTP 응답에 캐시 유효 기간이 존재한다. 클라이언트가 응답받은 자원을 임시 저장하여 이용하다가 유효 기간이 만료되면 다시 서버에 자원을 요청한다.
- 유효 기간을 두는 이유는 캐시 신선도 때문이다(캐시 사본과 원본이 달라질 수 있기 때문이다)
- 캐시 기간이 지나도, 원본 데이터가 변하지 않았다면 유효 기간을 연장할 수 있다. 변경 여부 확인 기준은 날짜와 엔티티 태그가 존재한다.
- 날짜를 기준할 경우, 다음과 같이 작동한다.

    - 서버가 요청받은 자원이 변경된 경우, 200 상태 코드와 변경된 자원을 반환한다.

    - 서버가 요청받은 자원이 변경되지 않은 경우, 304 상태 코드와 Last-Modified 헤더로 자원의 마지막 변경 시점을 반환한다.
    - 서버가 요청받은 자원이 삭제된 경우, 404 상태 코드를 통해 요청한 자원이 존재하지 않음을 알린다.

- 엔티티 태그를 기준할 경우, 다음과 같이 작동한다.
    - If-None-Match 헤더에 엔티티 태그(Etag)를 입력하며 자원 반환을 요청한다.
    - 날짜와 같은 방식으로 상태 코드와 자원을 반환한다.

## 콘텐츠 협상

- HTTP 메세지를 통해 주고 받는 것은 엄밀히 말하면 ‘자원의 표현’이다. 즉, 같은 URI에 대해서도 다른 자원의 표현이 있을 수 있다.

- 이 중, 가장 적합한 자원의 표현을 제공하는 기술을 콘텐츠 협상이라고 한다.
- 이는 Accept, Accept-Language, Accept-Encoding 이라는 헤더를 통해 설정할 수 있다.

## 보안: SSL/TLS와 HTTPS

SSL/TLS와 HTTPS

- SSL/TLS는 모두 인증과 암호화를 수행하는 프로토콜로, HTTP와 붙어서 HTTPS 프로토콜로 동작한다.

- HTTPS 메세지 작동 흐름은 기존 3WH와 메세지 사이에 TLS 핸드쉐이크가 추가된 형태다.
- TLS 핸드쉐이크를 통해 암호화 통신을 위해 키를 생성 및 교환할 수 있다
- TLS 핸드쉐이크를 통해 인증서 송수신과 검증이 이루어질 수 있다.

TLS 핸드쉐이크 과정

- ClientHello(key_share)

    - 서버에 TLS 핸드쉐이크를 위한 신호를 보낸다
    - 이 과정에서 지원되는 TLS 버전, 사용 가능한 암호화 알고리즘, 해시 함수, 클라이언트 난수 등을 포함해 전송하며, 이를 암호 스위트라고 한다.

    - 예를 들어, TLS_AES_128_GCM_SHA256가 있다
- ServerHello(key_share)

    - ClientHello로부터 받은 암호 스위트를 확인하고 선택하는 과정이다.
- EncryptedExtensions

    - 세부 확장 기능을 암호환된 상태로 주고 받는다.(구체적인 협상 진행)
- Certificate, CertificateVerify

    - 인증서 및 인증서 검증 관련 메세지를 전송한다. 인증서가 올바른지 확인하는 과정이다.

    - 여기서 인증서는 해당 도메인이 유효함을 인증 기관이 보장해준 증명서로 이해할 수 있다.
- Finished
    - TLS 핸드쉐이크가 마무리됨을 알려준다.

https://inuplace.tistory.com/1086

# 프록시와 안정적인 트래픽

## 오리진 서버와 중간 서버: 포워드 프록시와 리버스 프록시

오리진 서버와 중간 서버

- 클라이언트와 서버 사이에 수많은 네트워크 장비 및 중간 서버가 존재하며, 이들은 각각의 책임과 역할이 구분되어 있다.

- 여기서 자원을 생성하고 클라이언트에게 권한이 있는 응답을 보낼 수 있는 HTTP 서버를 오리진 서버라고 한다.(클라이언트와 오리진 서버는 엔드 투 엔드)

프록시와 게이트웨이

- 프록시와 게이트웨이는 각각 포워드 프록시, 리버스 프록시로 불리며, 클라이언트와 오리진 서버 사이의 위치에 따라 정해졌다.

- 프록시는 클라이언트에 가까우며 클라이언트가 선택한 메세지 전달의 대리자로, 캐시 저장, 클라이언트 암호화 및 접근 제한 등의 역할을 한다.
- 프록시는 클라이언트가 선택할 수 있으므로 클라이언트 사이드라고 불리는거 같다.
- 게이트웨이는 오리진 서버로 향하는 메세지를 먼저 받아 오리진 서버에게 전달하는 역할을 한다.
- 게이트웨이는 캐시 저장, 로드 밸런싱 역할을 한다.
- 게이트웨이는 오리진 서버들 사이드에서 직접 서버들과 연결되기 때문에 서버 사이드라고 불리는거 같다.

## 고가용성: 로드 밸런싱과 스케일링

가용성

- 주어진 시간 동안 업무를 정상적으로 수행하는 시간의 비율을 의미한다.

- 이는 안정성을 의미하며, 보통 99.999 이상을 목표로 한다.
- 고가용성을 유지하기 위해선 ‘외부 문제에 대한 예방’보다 ‘문제가 발생하더라도 계속 기능할 수 있도록 설계’에 목표를 두어야 하며, 이를 결함 감내라고 한다.
- 서버 다중화 시 특정 서버에 문제가 발생할 수 있는데 이를 헬스 체크와 하트비트로 해결할 수 있다.

로드 밸런싱

- 서버로 전달되는 트래픽을 고르게 분산하기 위한 기술이다. 이를 수행하는 장치를 로드 밸런서라고 한다.

- 로드 밸런서는 L4, L7 스위치에서 주로 사용되지만 Nginx와 같은 SW를 설치하면 일반 호스트도 로드 밸런서로 사용할 수 있다.
- 트래픽 배분 방식을 정할 수 있는 로드 밸런싱 알고리즘이 존재한다

    - 라운드 로빈 알고리즘 : 단순히 서버를 돌아가며 부하를 전달한다

    - 최소 연결 알고리즘 : 연결이 적인 서버부터 우선적으로 부하를 전달한다
    - 가중치 기반 알고리즘 : 서버의 성능에 맞춰 부하를 전달한다

스케일링

- 스케일 업(수직적 확장)

    - 서버의 스펙을 증가시키는 확장 방식이다.

    - 설치와 구성이 단순하다는 장점이 있다.
    - 트래픽의 변화에 따라 스펙을 확장 및 축소할 수 없다는 점, SPOT 문제가 생길 수 있다는 점, 가격이 굉장히 비싸진다는 점이 단점으로 작용한다.
- 스케일 아웃(수평적 확장)
    - 서버의 대수를 증기시키는 확장 방식이다.

    - SPOT 문제를 해결해 결함을 감내할 수 있다는 점, 가격이 상대적으로 괜찮다는 점, 트래픽의 변화에 따라 유연하게 스펙을 변경할 수 있다는 장점이 있다.
    - 단점은 글쎄.. 구축 방법이 상대적으로 까다롭다는 거..?

오토 스케일링

- 필요할 때마다 시스템을 동적으로 확장하고 축소할 수 있는 기능이다.

- 티켓팅과 같은 트래픽 변화에 대응할 수 있으며, 인프라를 더욱 탄력적으로 이용할 수 있다.

## Nginx로 알아보는 로드 밸런싱

Nginx

- 네 잘 따라하시면 됩니다

- 요긴한게 많아서 이상한 블로그 뒤지는거보다 이거 한 번 읽고 따라하시는게 좋을거 같습니다

용어

- 업스트림은 상위 서버로 데이터를 보내는 방향, 다운스트림은 하위 서버로 데이터를 보내는 방향을 의미한다.

- “클라이언트 → 서버” 를 업스트림, “서버 → 클라이언트” 를 다운스트림이라고 한다.
- 인바운드는 네트워크 외부 → 내부, 아웃바운드는 네트워크 내부 → 외부 로의 흐름을 의미한다.

## 웹 서버와 웹 애플리케이션 서버

웹 서버와 WAS

- 웹 서버는 HTML, 이미지와 같이 정적인 정보를 응답한다.

- WAS는 동적인 정보를 응답한다. 대표적으로 아파치 톰캣, JBOSS 등이 존재한다.
- 웹 서버와 WAS는 함께 사용되며, 정보의 성격(정적, 동적)을 기준으로 역할을 나눠 작동한다. 이는 과도한 부하 분산을 해결하며, 여러 웹 애플리케이션을 연동하여 확장하는 데 유리하다.
- 여기서 스프링과 톰캣을 헷갈릴 수 있는데, 스프링은 코드를 만드는 데 도움을 주는 도구고, 톰캣은 스프링으로 만든 코드를 컨테이너로 띄우는 기술이다?

## 소캣 프로그래밍

- 소켓은 프로세스 간 네트워크 통신의 엔드포인트를 의미한다.