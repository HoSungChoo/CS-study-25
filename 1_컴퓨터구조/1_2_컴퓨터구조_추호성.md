# 4. 메모리

## RAM

정의

- 휘발성 저장장치이며 임의 접근(특정 주소에 한번에 접근하는 방식. 순차 접근과 비교되는 개념)이 가능하다.

- RAM의 종류에 따라 데이터 전송 속도의 차이가 존재하며, 여기서 전송 대상은 CPU와 RAM 간의 소통을 의미한다.(엄밀히 CPU 내부의 메모리 컨트롤러와 소통한다.)

종류

- DRAM
    - 시간이 지나면 저장된 데이터가 소실된다. → 일정 주기로 재활성화해야 한다.

    - 상대적으로 속도가 느리다.

    - 낮은 소비 전력, 낮은 가격, 높은 집적도를 가진다 → 대용량 설계가 쉽다.

    - 집적도 : 집적도는 특정 공간이나 지역 안에 얼마나 많은 요소가 밀집해 있는지를 나타내는 지표

- SRAM
    - 시간이 지나도 저장된 데이터가 사라지지 않는다. (비교적 느리게 사라진다)

    - 상대적으로 속도가 빠르다.

    - 높은 소비 전력, 높은 가격, 낮은 집적도를 가진다 → 캐시 메모리 등에서 사용된다.

- SDRAM
    - 클럭에 맞춰 작동하는 DRAM이다. 클럭 신호에 맞춰 CPU와 정보를 주고받을 수 있다.

    - 기존 DRAM과 비교해 속도가 빠르다.

- DDR SDRAM
    - 대역폭을 넓혀 속도를 개선한 SDRAM이다.

    - 기존 상승 엣지에 데이터를 전송하는 SDRAM과 달리 상승, 하강 엣지 모두에 데이터를 전송하기 때문에 클럭 당 전송할 수 있는 데이터의 수가 2배 증가했다.

    - 도로가 두 배 넓어졌다고 말하는게 맞나..?

    - DDR SDRAM은 버전이 증가함에 따라 전송 데이터의 수가 2배씩 증가한다.

## 엔디안 체계

정의

- RAM의 경우 데이터를 1바이트 단위로 저장하지만 CPU와는 1워드 단위로 소통한다. 여기서 소통하는 1워드 데이터를 어떤 순서로 읽는지 결정하는 체계가 엔디안 체계다.

- 읽는 순서에 따라 빅 엔디안, 리틀 엔디안으로 구분된다. 빅 엔디안은 낮은 번지의 주소에 상위 바이트(가장 큰 값)부터 저장하는 방식이며, 리틀 엔디안은 그 반대다.
- 예를 들어 CPU로부터 1A 2B 3C 4D 데이터를 읽는다고 가정하자.

    - 빅 엔디안은 1A 값을 낮은 주소에, 4D 값을 높은 주소에 저장한다.

    - 리틀 엔디안은 4D 값을 낮은 주소에, 1A 값을 높은 주소에 저장한다.
    
![img](https://github.com/user-attachments/assets/dd26a088-f888-4dd0-a600-9bfeae93ffa2)

특징

- 빅 엔디안은 디버깅, 프로그래밍 과정에서 읽기 쉽다는 장점이 있다. 우리가 일상적으로 읽고 쓰는 데이터 순서와 일치하기 때문이다(우리는 보통 데이터를 낮은 주소에서 높은 주소 방향으로 읽는다)

- 리틀 엔디안은 수치 계산이 편하다는 장점이 있다. 낮은 주소부터 시작해서 값을 계산하기 때문이다.


## 캐시 메모리

정의

- CPU와 메모리 사이의 속도 차이를 줄이기 위한 장치

- 대표적으로 L1, L2, L3 캐시가 존재한다.
- L1, L2는 코어마다 고유하며, L3는 모든 코어가 공유한다.
- L1 캐시 중 명령어를 저장하는 캐시를 L1I, 데이터를 저장하는 캐시를 L1D라고 한다. 이를 분리형 캐시라고 한다.

캐시 히트

- 캐시는 보통 CPU가 자주 사용하는 데이터를 저장한다.

- CPU가 데이터를 불러올 때 캐시를 먼저 탐색하며, 데이터가 존재할 경우 이를 캐시 히트라고 한다.
- 캐시에 데이터가 탐색되지 않을 경우, 메모리에서 데이터를 불러오며, 이를 캐시 미스라고 한다.
- 일반적으로 컴퓨터의 캐시 적중률은 85 ~ 95% 정도다.

참조 지역성

- CPU는 비슷한 데이터를 반복적으로 사용하며, 이는 참조 지역성을 기반한다.

- 참조 지역성은 시간 지역성과 공간 지역성을 나뉜다.
- 시간 지역성은 CPU가 최근에 접근했던 메모리 공간에 다시 접근하려는 경향을 의미한다. 변수의 선언과 반복적 사용을 예로 들 수 있다.
- 공간 지역성은 CPU가 접근한 메모리 공간의 근처에 접근하려는 경향을 의미한다. 배열의 선언과 순회를 예로 들 수 있다.
- 이차원 배열의 순회 순서를 통해 공간 지역성의 중요성을 자각할 수 있다. 보통 가로축 기반 순회가 더 빠른데, 이는 이차원 배열의 메모리 할당 방식이 원인이다.

캐시 메모리의 일관성

- 캐시는 항상 속도와 일관성에서 trade-off된다.

- 캐시에 쓰기를 진행할 경우, 일관성 유지를 위해 메모리도 값을 수정해야 한다.
- 쓰기 종류에는 즉시 쓰기(write-through), 지연 쓰기(write-back)가 존재한다.
- 즉시 쓰기는 캐시에 데이터를 쓰는 경우, 즉시 메모리에도 쓰기를 진행하는 방식이다. 이는 속도를 늦추지만 높은 일관성을 가질 수 있다.
- 지연 쓰기는 일정 주기로 캐시에서 쓰여진 데이터를 메모리에도 쓰는 방식이다. 이는 즉시 쓰기와 비교했을 때 속도가 개선되지만 일관성이 떨어질 수 있다.
- 캐시 일관성은 메모리에만 적용되는 것이 아닌 L3와 같은 캐시에도 적용된다. 아니 모든 캐시 메커니즘에 적용된다.

캐시 읽기 전략

- Look-aside 패턴

    - 캐시에서 먼저 데이터를 읽고 없으면 메모리에서 읽어오는 방식

    - 메모리에서 읽은 데이터를 캐시에 업데이트한다.
    - 캐시와 메모리가 분리되어 가용되기 때문에 캐시 장애에 대비할 수 있다.
    - 어떤 단점이 있나?
- Read-through 패턴
    - 캐시에서만 데이터를 읽어오는 방식

    - 캐시에 데이터가 없는 경우 메모리에서 데이터를 읽고 캐시에 업데이트한다.
    - 캐시 데이터와 메모리 데이터가 항상 일관성을 가진다는 장점이 있다. 데이터를 읽을 때 항상 캐시를 거쳐야 하기 때문이다.
    - 쓰기 잘못하면 일관성 꺠지지 않나? → write-through와 조합해서 사용해야 한다. → 속도 많이 느려질듯..
    - 캐시에 장애가 발생할 경우, 전체 장애가 발생할 수 있다는 단점이 있다.


# 5. 보조기억장치와 입출력 장치

## RAID

정의

- 데이터의 안전성 혹은 성능을 확보하기 위해 여러 개의 보조기억장치를 하나로 조합하는 기술이다.

- RAID 구성 방법에 따라 데이터의 안정성 혹은 성능을 개선할 수 있다(이 역시 trade-off가 발생한다)
- RAID 구성 방법을 RAID 레벨이라고 하며, 0, 1, 4, 5, 6이 대표적이다.

RAID0

- 데이터를 여러 보조기억장치에 나누어 저장하는 방식이다.

- 분산된 데이터를 스트라입, 분산하여 저장하는 방식을 스트라이핑이라고 한다.
- 빠른 입출력 속도가 장점이다. 분산된 디스크 각각의 일부 데이터를 가져와 조합하면 되기 때문이다.
- 저장된 정보가 안전하지 않다는 단점이 있다. 디스크 일부에 장애가 발생하면 모든 데이터가 불완전해지기 때문이다.
  
![image (6)](https://github.com/user-attachments/assets/77230db0-d8df-48f8-90a9-2c7bc7b6cb9c)

RAID1

- 완전한 복사본을 만들어 저장하는 방식이다.

- RAID0과 같이 처리하되, 별도 디스크를 통해 이중화하는 방식이다. 이를 미러링이라고 부른다.
- 안전성이 증가하지만 쓰기 시간이 증가(두번 쓰기 때문에)하며 사용 가능한 용량이 줄어든다는 단점이 있다.

![image (7)](https://github.com/user-attachments/assets/9cf2de8a-0c3b-445e-bee3-a09c9a67461c)

RAID4

- 패리티 정보를 저장하는 디스크를 별도로 구성하는 방식이다.

- 패리티 정보는 정보가 저장된 디스크의 같은 row값을 XOR한 값으로 저장한다. → 오류 감지가 가능하며, 특정 디스크에 오류가 발생할 경우 패리티 정보를 기반으로 복구 가능하다.

- 패리티 정보를 저장하는 디스크는 1개로 구성되기 때문에 RAID4에 비해 가용 디스크 용량이 늘어난다는 장점이 있다.
- 그러나 디스크 패리티 디스크의 쓰기 부하 문제로 병목 현상이 발생할 수 있다. 또한, 동시에 두 개 이상의 디스크에 오류가 발생하면 복구가 불가능하다.
  
![image (8)](https://github.com/user-attachments/assets/032404af-12b9-4c12-a881-e1c1b31c39e6)

RAID5

- 패리티를 분산하여 저장하는 구조다.

- 패리티 쓰기 부하를 여러 디스크가 분산하기 때문에 병목을 해결할 수 있다.

![image (9)](https://github.com/user-attachments/assets/b85b1959-ccb2-4aed-b7f5-c8b15329c3be)

RAID6

- 패리티 디스크를 2개 두는 구조다. 또한, RAID5와 같이 패리티 정보를 분산하여 저장한다.

- 디스크를 2개까지 복구 가능하기 때문에 내결함성이 강력하다.
- 패리티를 두 번 입력해야 하기 때문에 쓰기 속도가 느리다는 단점이 있다.

![image (10)](https://github.com/user-attachments/assets/fb3b5032-3b04-46c0-8f72-dc66fe5107c9)

## 입출력 기법

장치 컨트롤러

- CPU와 입출력장치 사이에서 데이터를 중재

- 규격이 다른 입출력장치를 추상화하며 CPU와 통신을 중개하는 역할
- 장치 고유의 동작을 수행하도록 제어
- 입출력 신호 해석, 데이터 버퍼링, 인터럽트 발생, 레지스터 제공 과 같은 역할을 한다.

장치 드라이버

- 운영체제의 일종으로, 특정 장치 컨트롤러의 동작 방식을 이해하고 제어하는 역할

- OS와 장치 컨트롤러 사이의 인터페이스 역할
- 명령 전달, 데이터 형식 변환, 에러 처리와 같은 역할

전체 흐름

- 애플리케이션 → OS → 장치 드라이버 → 장치 컨트롤러 → 정치 드라이버 → 장치

- CPU와 장치 컨트롤러가 정보를 주고받는 작업은 3가지가 존재한다.

프로그램 입출력

- 프로그램 속 명령어로 입출력 작업을 수행하는 방법

- CPU가 입출력 장치를 제어하고 데이터를 주고받는 방식의 차이에 따라 두 종류로 나뉜다.
- 고립형 입출력
    - 입출력 장치의 주소 공간과 메모리 주소 공간을 분리한 방식
- 메모리 맵 입출력
    - 입출력 장치도 메모리 주소 공간의 일부처럼 취급

인터럽트 기반 입출력 : 다중 인터럽트

- 여러 인터럽트가 동시에 요청되는 경우, 우선순위를 기반으로 인터럽트가 처리된다.

- 특정 인터럽트 A 처리 중, 우선 순위가 더 높은 인터럽트 B 가 입력되는 경우, 진행 중인 인터럽트 A를 중지하고 인터럽트 B를 처리한 뒤 인터럽트 A를 처리한다.
- 여기서 인터럽트는 비동기 인터럽트이므로 CPU 명령어 처리 사이클 중 특정 단계에서 인터럽트를 처리함을 알아야 한다.

프로그래머블 인터럽트 컨트롤러(PIC)

- PIC를 통해 다중 인터럽트를 처리한다.

- PIC는 여러 장치 컨트롤러에 연결되며, 해당 장치들이 보낸 하드웨어 인터럽트 요청들의 우선순위를 판단하고 이를 CPU에게 알려주는 역할을 한다.
- PIC는 2개 이상의 계층으로 구성되어 있다.

DMA 입출력

- 입출력장치와 메모리가 상호작용할 수 있는 입출력 방식이며, CPU 대신 DMA 컨트롤러가 이를 관리한다. 즉, CPU의 업무 부담을 덜어준다.

- DMA는 작접 메모리에 접근할 수 있는 입출력 기능을 의미한다.
- DMA 컨트롤러는 시스템 버스에 연결되며, 장치 컨트롤러는 입출력 버스에 연결되어 소통한다.
- 작동 과정은 다음과 같다.

    - CPU가 DMAC에게 입출력장치의 주소, 연산, 오퍼랜드 값을 제공하며 입출력 작업을 명령한다.

    - DMAC이 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다. 이 때, DMAC은 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 쓴다.
    - DMAC은 입출력 작업이 끝나면 CPU에 인터럽트를 걸어 종료를 알린다.

입출력 버스

- 장치마다 연결되며 데이터를 주고받을 수 있는 통로 역할을 한다.

- 버스를 통한 데이터 이동이 겹칠 수 없다.
- 대표적으로 PCIe가 존재한다.
- PCIe 버스는 지속적으로 발전하기 때문에 버전이 존재한다.
- PCIe 버스에서 레인은 버스를 통해 정보를 송수신하는 단위를 의미한다. 레인의 숫자는 데이터 송신량에 비례한다.
